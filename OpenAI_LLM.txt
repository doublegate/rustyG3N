Project Path: rustyG3N

Source Tree:

```
rustyG3N
├── Cargo.lock
├── Cargo.toml
├── roms
│   └── SonicTheHedgehog.bin
├── src
│   ├── display.rs
│   ├── m68k_cpu.rs
│   ├── main.rs
│   ├── memory.rs
│   ├── vdp.rs
│   └── z80_cpu.rs
└── target
    ├── CACHEDIR.TAG
    └── release
        ├── build
        ├── deps
        │   ├── rustyG3N.d
        │   ├── rustyG3N.exe
        │   └── rustyG3N.pdb
        ├── examples
        ├── incremental
        ├── rustyG3N.d
        ├── rustyG3N.exe
        └── rustyG3N.pdb

```

`\\?\C:\Users\parobek\GitHub\rustyG3N\Cargo.toml`:

```toml
[package]
name = "rustyG3N"
version = "0.1.0"
edition = "2021"

[dependencies]

```

`\\?\C:\Users\parobek\GitHub\rustyG3N\src\display.rs`:

```rs
use minifb::{Window, WindowOptions, Scale};

pub struct Display {
    window: Window,
    width: usize,
    height: usize,
}

impl Display {
    pub fn new(width: usize, height: usize, scale: f32) -> Self {
        let mut window = Window::new(
            "rustyGEN",
            width,
            height,
            WindowOptions {
                scale: match scale {
                    s if s <= 1.0 => Scale::X1,
                    s if s <= 2.0 => Scale::X2,
                    s if s <= 4.0 => Scale::X4,
                    _ => Scale::X8,
                },
                ..WindowOptions::default()
            },
        ).expect("Failed to create window");
        window.limit_update_rate(Some(std::time::Duration::from_secs_f32(1.0 / 60.0)));
        Display { window, width, height }
    }

    pub fn update(&mut self, buffer: &[u32], width: usize, height: usize) {
        self.window.update_with_buffer(buffer, width, height).unwrap();
    }

    pub fn is_open(&self) -> bool {
        self.window.is_open()
    }

    pub fn is_key_down(&self, key: minifb::Key) -> bool {
        self.window.is_key_down(key)
    }
}

```

`\\?\C:\Users\parobek\GitHub\rustyG3N\src\m68k_cpu.rs`:

```rs
//! m68k_cpu.rs - Motorola 68000 (68k) CPU Emulator Core
//! --- Version 0.3.1
//!
//! This file implements the core of a Motorola 68000 CPU emulator. It defines the essential
//! components including CPU registers (data and address registers), a program counter, status
//! register, and a memory interface. The code handles instruction prefetching, decoding, execution,
//! cycles calculation, as well as exceptions and interrupts, providing a comprehensive emulation of
//! the 68k CPU behavior.
//!
//! # Features
//!
//! - **Instruction Decoding and Execution:** Implements a broad range of 68k operations such as
//!   arithmetic (ADD, SUB, MULS, DIVU, DIVS), logical (AND, OR, EOR, NOT), bit manipulation (BSET,
//!   BCLR, BCHG, BTST), control flow (Branch, Jump, JSR, RTS), and more.
//! - **Addressing Modes:** Supports multiple addressing modes including Data/Register Direct,
//!   Address Register Indirect, Indexed, Displacement, PC-relative modes, Immediate, and more.
//! - **Cycle-Accurate Emulation:** Computes execution cycles dynamically based on addressing modes,
//!   operand sizes, and operations, aiming for accurate timing in emulation.
//! - **Exception and Interrupt Handling:** Provides mechanisms to trigger exceptions (e.g., Address
//!   Error) and manage interrupts with nested interrupt levels and bus state management.
//! - **Memory Operations:** Implements safe memory access routines for byte, word, and long
//!   operations, complete with error handling to integrate with the exception system.
//!
//! # Implementation Details
//!
//! - **CPU Structure:** The main `CPU` struct encapsulates:
//!   - General-purpose registers (D0-D7 and A0-A7).
//!   - Program counter (`pc`), status register (`sr`), and a memory interface.
//!   - A prefetch queue to optimize instruction fetching.
//!   - Cycle counting for tracking execution time.
//!   - Internal state flags, such as `exception_in_progress` to manage recursive exceptions.
//!
//! - **Instruction Decoding:** The `decode()` function fetches an opcode, interprets addressing modes,
//!   and generates an `Instruction` struct that contains the operation code, optional size, source, and
//!   destination operands.
//!
//! - **Execution Engine:** The `execute()` function matches the decoded instruction's operation, performs
//!   the required read/write operations, updates CPU flags and registers, and computes the operation's
//!   cycle cost.
//!
//! - **Memory and Bus Management:** Memory read/write abstraction and bus state transitions are managed
//!   to emulate the actual hardware behavior, including interrupt acknowledgement and data transfer
//!   delays.
//!
//! # Technical Strategy
//!
//! - The design leverages Rust’s strong type system using enums (`Operation`, `Operand`, and `Size`) to
//!   enforce correctness and clarity.
//! - Each CPU operation is implemented with precise control over operand handling, flag updates, and cycle
//!   counting, making the emulation both accurate and modular.
//! - Safety and error handling are integral, with checks for addressing and memory errors to trigger
//!   exceptions, thus preventing unintended recursive fault conditions.
//!
//! # Versioning and Maintenance
//!
//! - Version: 1.0.0
//! - Part of the m68k_emulator project.
//! - Recent updates include improved addressing mode decode logic, refined cycle counting, and enhanced
//!   exception handling.
//!
//! # Usage
//!
//! - Create a new CPU instance with a memory implementation using `CPU::new(memory)`.
//! - Control execution by repeatedly fetching, decoding, and executing instructions.
//! - Utilize provided methods for injecting interrupts and handling CPU exceptions.
//!
//! # Future Enhancements
//!
//! - Extend the instruction set with additional 68k operations.
//! - Integrate more detailed cycle-accurate simulation and hardware-level timing.
//! - Improve debugging support with detailed logging and tracing capabilities.
//!
//! # Authors and Contributors
//!
//! - Original Author: DoubleGate
//! - GitHub Location: https://github.com/doublegate/m68k_emulator/blob/main/src/m68k_cpu.rs
//!
//! # License
//!
//! - Distributed under the MIT License.
//! 
// src/m68k_cpu.rs
// use crate::memory::Memory;
// use crate::memory::Exception;

pub trait M68kMemory {
    fn read_byte(&mut self, address: u32) -> Result<u8, Exception>;
    fn read_word(&mut self, address: u32) -> Result<u16, Exception>;
    fn read_long(&mut self, address: u32) -> Result<u32, Exception>;
    fn write_byte(&mut self, address: u32, value: u8) -> Result<(), Exception>;
    fn write_word(&mut self, address: u32, value: u16) -> Result<(), Exception>;
    fn write_long(&mut self, address: u32, value: u32) -> Result<(), Exception>;
}

#[derive(Debug)]
pub enum Exception { AddressError }

#[derive(Debug, Clone, Copy, PartialEq)] // Add PartialEq
pub enum Size {
    Byte,
    Word,
    Long,
}

impl Size {
    fn bits(&self) -> u32 {
        match self {
            Size::Byte => 8,
            Size::Word => 16,
            Size::Long => 32,
        }
    }

    fn mask(&self) -> u32 {
        match self {
            Size::Byte => 0xFF,
            Size::Word => 0xFFFF,
            Size::Long => 0xFFFFFFFF,
        }
    }
}

#[derive(Debug, Clone)]
pub enum Operand {
    DataRegister(u8),
    AddressRegister(u8),
    Indirect(u8),
    PostInc(u8),
    PreDec(u8),
    Displacement(u8, i16),
    Indexed(u8, i8, u8, Size),
    AbsoluteShort(u32),
    AbsoluteLong(u32),
    PCDisplacement(i16),
    PCIndexed(i8, u8, Size),
    Immediate(u32),
}

#[derive(Debug, PartialEq)] // Add PartialEq
pub enum Operation {
    Nop,
    Rts,
    Move,
    Add,
    Muls,
    Divu,
    Eor,
    Neg,
    Tst,
    Lsr,
    Asl,
    Moveq,
    Ror,
    Eori,
    Cmpi,
    Movep,
    Bclr,
    Lea,
    Ext,
    Sub,
    Andi,
    Ori,
    Addx,
    Subx,
    Bra,
    Beq,
    Bne,
    Clr,
    Swap,
    Cmpa,
    Chk,
    Tas,
    Rol,
    Roxl,
    Jsr,
    Bchg,
    Bset,
    Btst,
    Trap,
    And,
    Or,
    Addq,
    Subq,
    Not,
    Divs,
    Roxr,
    Bhi,
    Bls,
    Jmp,
    Adda,
    Suba,
    Mulu,
    Cmp,
    Scc,
    Dbcc,
    Pea,
    Link,
    Unlk,
    NopAlt,
    Bgt,
    Ble,
    Exg,
    Movem,
    AslMem,
    LsrMem,
    ClrMem,
    Stop,
    Rtd,
    TasMem,
    Bcc,
    Bcs,
    Bge,
    Blt,
    Bmi,
    Bpl,
    Lsl,
    RolMem,
    RorMem,
    Subi,
    Abcd,
    Sbcd,
    Nbcd,
    Addi,
    Bvc,
    Bvs,
    RoxlMem,
    RoxrMem,
    Trapv,
    Reset,
    Rte,
    Movea,
    MoveCcr,
    MoveSr,
    MoveUsp,
    AndiCcr,
    OriCcr,
    EoriCcr,
    LslMem,
    Asr,
}

#[derive(Debug)]
struct Instruction {
    operation: Operation,
    size: Option<Size>,
    src: Option<Operand>,
    dst: Option<Operand>,
}

pub struct CPU<M: M68kMemory> {
    pub d: [u32; 8],
    pub a: [u32; 8],
    pub pc: u32,
    pub sr: u16,
    pub memory: M,
    pub cycle_count: u64,
    pending_interrupts: Vec<(u8, Option<u8>)>, // Use Vec with capacity
    interrupt_ack: Option<u8>,
    interrupt_nest_level: u8,
    bus_state: BusState,
    pub halted: bool,
    prefetch_queue: [u16; 2],
    exception_in_progress: bool, // Flag to prevent recursive exceptions
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum BusState {
    Idle,
    Iack(u8),
    Vpa,
    Dtack(u8),
}

impl<M: M68kMemory> CPU<M> {
    pub fn new(memory: M) -> Self {
        CPU {
            d: [0; 8],
            a: [0; 8],
            pc: 0, // PC is initialized later
            sr: 0x2700,
            memory,
            cycle_count: 0,
            pending_interrupts: Vec::with_capacity(8), // Pre-allocate
            interrupt_ack: None,
            interrupt_nest_level: 0,
            bus_state: BusState::Idle,
            halted: false,
            prefetch_queue: [0; 2],
            exception_in_progress: false, // Initialize exception flag
        }
    }

    fn cpu_read_byte(&mut self, address: u32) -> u8 {
        match self.memory.read_byte(address) {
            Ok(value) => value,
            Err(Exception::AddressError) => {
                if !self.exception_in_progress { // Avoid recursion
                    self.exception_in_progress = true;
                    self.trigger_exception(3);
                    self.exception_in_progress = false;
                }
                0 // Return a safe value, don't propagate error
            }
        }
    }

    fn cpu_read_word(&mut self, address: u32) -> u16 {
        match self.memory.read_word(address) {
            Ok(value) => value,
            Err(Exception::AddressError) => {
                if !self.exception_in_progress {
                    self.exception_in_progress = true;
                    self.trigger_exception(3);
                    self.exception_in_progress = false;
                }
                0 // Avoid propagating AddressError
            }
        }
    }

    fn cpu_read_long(&mut self, address: u32) -> u32 {
        match self.memory.read_long(address) {
            Ok(value) => value,
            Err(Exception::AddressError) => {
                if !self.exception_in_progress {
                    self.exception_in_progress = true;
                    self.trigger_exception(3);
                    self.exception_in_progress = false;
                }
                0 // Avoid propagating AddressError
            }
        }
    }

    fn cpu_write_byte(&mut self, address: u32, value: u8) {
        if let Err(Exception::AddressError) = self.memory.write_byte(address, value) {
            self.trigger_exception(3);
        }
    }

    fn cpu_write_word(&mut self, address: u32, value: u16) {
        if let Err(Exception::AddressError) = self.memory.write_word(address, value) {
            self.trigger_exception(3);
        }
    }

    fn cpu_write_long(&mut self, address: u32, value: u32) {
        if let Err(Exception::AddressError) = self.memory.write_long(address, value) {
            self.trigger_exception(3);
        }
    }

    pub fn prefetch(&mut self) {
        self.prefetch_queue[0] = self.cpu_read_word(self.pc);
        self.prefetch_queue[1] = self.cpu_read_word(self.pc + 2);
        self.pc += 4;
    }

    fn fetch_word(&mut self) -> u16 {
        let word = self.prefetch_queue[0];
        self.prefetch_queue[0] = self.prefetch_queue[1];
        self.prefetch_queue[1] = self.cpu_read_word(self.pc);
        self.pc += 2;
        word
    }

    fn fetch_long(&mut self) -> u32 {
        let high = self.fetch_word() as u32;
        let low = self.fetch_word() as u32;
        (high << 16) | low
    }

    fn set_flags(&mut self, n: bool, z: bool, v: bool, c: bool, x: bool) {
        let mut sr = self.sr & 0xFFF0;
        if n {
            sr |= 0x8;
        }
        if z {
            sr |= 0x4;
        }
        if v {
            sr |= 0x2;
        }
        if c {
            sr |= 0x1;
        }
        if x {
            sr |= 0x10;
        }
        self.sr = sr;
    }

    fn ea_cycles(&self, operand: &Operand, size: Size) -> u32 {
        match operand {
            Operand::DataRegister(_) => 0,
            Operand::AddressRegister(_) => 0,
            Operand::Indirect(_reg) => match size {
                Size::Byte | Size::Word => 4,
                Size::Long => 8,
            },
            Operand::PostInc(reg) => {
                if *reg == 7 && size == Size::Byte {
                    6
                } else {
                    match size {
                        Size::Byte | Size::Word => 4,
                        Size::Long => 8,
                    }
                }
            }
            Operand::PreDec(reg) => {
                if *reg == 7 && size == Size::Byte {
                    8
                } else {
                    match size {
                        Size::Byte | Size::Word => 6,
                        Size::Long => 10,
                    }
                }
            }
            Operand::Displacement(_, _) => match size {
                Size::Byte | Size::Word => 8,
                Size::Long => 12,
            },
            Operand::Indexed(_, _, _, _) => match size {
                Size::Byte | Size::Word => 10,
                Size::Long => 14,
            },
            Operand::AbsoluteShort(_) => match size {
                Size::Byte | Size::Word => 8,
                Size::Long => 12,
            },
            Operand::AbsoluteLong(_) => match size {
                Size::Byte | Size::Word => 12,
                Size::Long => 16,
            },
            Operand::PCDisplacement(_) => match size {
                Size::Byte | Size::Word => 8,
                Size::Long => 12,
            },
            Operand::PCIndexed(_, _, _) => match size {
                Size::Byte | Size::Word => 10,
                Size::Long => 14,
            },
            Operand::Immediate(_) => match size {
                Size::Byte => 0,
                Size::Word => 4,
                Size::Long => 8,
            },
        }
    }

    fn check_supervisor(&mut self) -> bool {
        (self.sr & 0x2000) != 0
    }

    pub fn request_interrupt(&mut self, level: u8, vector: Option<u8>) {
        if level > 7 || level == 0 {
            return;
        }
        if let Some(v) = vector {
            if v < 2 {
                return;
            }
        }
        if !self.pending_interrupts.iter().any(|&(l, v)| l == level && v == vector) {
            self.pending_interrupts.push((level, vector));
            self.pending_interrupts.sort_by(|a, b| b.0.cmp(&a.0));
        }
    }

    fn process_interrupt(&mut self, level: u8, vector: Option<u8>) -> u32 {
        self.halted = false;
        let mut cycles = 0;
        self.bus_state = BusState::Iack(level);
        self.interrupt_ack = Some(level);
        cycles += 14;
        let vec_addr = match vector {
            Some(v) => {
                self.bus_state = BusState::Dtack(v);
                cycles += 4;
                v as u32
            }
            None => {
                self.bus_state = BusState::Vpa;
                24 + level as u32
            }
        };
        self.sr |= 0x2000;
        self.sr = (self.sr & 0xF8FF) | ((level as u16) << 8);
        self.interrupt_nest_level += 1;
        self.a[7] -= 2;
        self.cpu_write_word(self.a[7], self.sr);
        self.a[7] -= 4;
        self.cpu_write_long(self.a[7], self.pc);
        cycles += 10;
        self.pc = self.cpu_read_long(vec_addr * 4);
        // Remove prefetch here, called in step()
        cycles += 4;
        self.bus_state = BusState::Idle;
        self.pending_interrupts.retain(|&(l, _)| l != level);
        cycles
    }

    pub fn trigger_exception(&mut self, vector: u32) -> u32 {
        if self.exception_in_progress {
            self.halted = true;
            return 0;
        }
        self.exception_in_progress = true;
    
        self.sr |= 0x2000; // Set supervisor mode
    
        // Relaxed validation: Accept any address within 16 MB memory range
        if self.a[7] >= 0x1000000 { // Beyond 16 MB
            println!("Invalid stack pointer A7: {:08X}", self.a[7]);
            self.halted = true;
            self.exception_in_progress = false;
            return 0;
        }
    
        self.a[7] = self.a[7].wrapping_sub(2);
        self.cpu_write_word(self.a[7], self.sr);
        self.a[7] = self.a[7].wrapping_sub(4);
        self.cpu_write_long(self.a[7], self.pc);
    
        let new_pc = self.cpu_read_long(vector * 4);
        if vector == 5 && new_pc == 0 {
            self.pc = 0x3000;
        } else {
            self.pc = new_pc;
        }
    
        self.exception_in_progress = false;
        self.halted = false;
        34 // Cycle count
    }

    pub fn get_interrupt_ack(&self) -> (Option<u8>, BusState) {
        (self.interrupt_ack, self.bus_state)
    }

    fn decode_ea(&mut self, mode: u8, reg: u8, size: Size) -> Operand {
        match mode {
            0 => Operand::DataRegister(reg),
            1 => Operand::AddressRegister(reg),
            2 => Operand::Indirect(reg),
            3 => Operand::PostInc(reg),
            4 => Operand::PreDec(reg),
            5 => {
                let disp = self.fetch_word() as i16;
                Operand::Displacement(reg, disp)
            }
            6 => {
                let ext = self.fetch_word();
                let disp = (ext as i8) as i8;
                let index_reg = (ext >> 12) & 0x7;
                let index_size = if (ext & 0x800) != 0 {
                    Size::Long
                } else {
                    Size::Word
                };
                Operand::Indexed(reg, disp, index_reg as u8, index_size)
            }
            7 => match reg {
                0 => Operand::AbsoluteShort(self.fetch_word() as u32),
                1 => Operand::AbsoluteLong(self.fetch_long()),
                2 => {
                    let disp = self.fetch_word() as i16;
                    Operand::PCDisplacement(disp)
                }
                3 => {
                    let ext = self.fetch_word();
                    let disp = (ext as i8) as i8;
                    let index_reg = (ext >> 12) & 0x7;
                    let index_size = if (ext & 0x800) != 0 {
                        Size::Long
                    } else {
                        Size::Word
                    };
                    Operand::PCIndexed(disp, index_reg as u8, index_size)
                }
                4 => {
                    let value = match size {
                        Size::Byte => (self.fetch_word() & 0xFF) as u32,
                        Size::Word => self.fetch_word() as u32,
                        Size::Long => self.fetch_long(),
                    };
                    Operand::Immediate(value)
                }
                _ => panic!("Invalid EA register: {}", reg),
            },
            _ => panic!("Invalid EA mode: {}", mode),
        }
    }

    fn get_operand_value(&mut self, size: Size, operand: &Operand) -> u32 {
        match operand {
            Operand::DataRegister(reg) => self.d[*reg as usize] & size.mask(),
            Operand::AddressRegister(reg) => self.a[*reg as usize],
            Operand::Indirect(reg) => {
                let addr = self.a[*reg as usize];
                match size {
                    Size::Byte => self.cpu_read_byte(addr) as u32,
                    Size::Word => self.cpu_read_word(addr) as u32,
                    Size::Long => self.cpu_read_long(addr),
                }
            }
            Operand::PostInc(reg) => {
                let addr = self.a[*reg as usize];
                let value = match size {
                    Size::Byte => self.cpu_read_byte(addr) as u32,
                    Size::Word => self.cpu_read_word(addr) as u32,
                    Size::Long => self.cpu_read_long(addr),
                };
                self.a[*reg as usize] += size.bits() / 8;
                value
            }
            Operand::PreDec(reg) => {
                self.a[*reg as usize] -= size.bits() / 8;
                let addr = self.a[*reg as usize];
                match size {
                    Size::Byte => self.cpu_read_byte(addr) as u32,
                    Size::Word => self.cpu_read_word(addr) as u32,
                    Size::Long => self.cpu_read_long(addr),
                }
            }
            Operand::Displacement(reg, disp) => {
                let addr = self.a[*reg as usize].wrapping_add(*disp as u32);
                match size {
                    Size::Byte => self.cpu_read_byte(addr) as u32,
                    Size::Word => self.cpu_read_word(addr) as u32,
                    Size::Long => self.cpu_read_long(addr),
                }
            }
            Operand::Indexed(reg, disp, idx_reg, idx_size) => {
                let base = self.a[*reg as usize];
                let index = match idx_size {
                    Size::Word => (self.d[*idx_reg as usize] as i16) as i32,
                    Size::Long => self.d[*idx_reg as usize] as i32,
                    _ => unreachable!(),
                };
                let addr = base.wrapping_add(*disp as i32 as u32).wrapping_add(index as u32);
                match size {
                    Size::Byte => self.cpu_read_byte(addr) as u32,
                    Size::Word => self.cpu_read_word(addr) as u32,
                    Size::Long => self.cpu_read_long(addr),
                }
            }
            Operand::AbsoluteShort(addr) => match size {
                Size::Byte => self.cpu_read_byte(*addr) as u32,
                Size::Word => self.cpu_read_word(*addr) as u32,
                Size::Long => self.cpu_read_long(*addr),
            },
            Operand::AbsoluteLong(addr) => match size {
                Size::Byte => self.cpu_read_byte(*addr) as u32,
                Size::Word => self.cpu_read_word(*addr) as u32,
                Size::Long => self.cpu_read_long(*addr),
            },
            Operand::PCDisplacement(disp) => {
                let addr = self.pc.wrapping_add(*disp as u32 - 2);
                match size {
                    Size::Byte => self.cpu_read_byte(addr) as u32,
                    Size::Word => self.cpu_read_word(addr) as u32,
                    Size::Long => self.cpu_read_long(addr),
                }
            }
            Operand::PCIndexed(disp, idx_reg, idx_size) => {
                let base = self.pc - 2;
                let index = match idx_size {
                    Size::Word => (self.d[*idx_reg as usize] as i16) as i32,
                    Size::Long => self.d[*idx_reg as usize] as i32,
                    _ => unreachable!(),
                };
                let addr = base.wrapping_add(*disp as i32 as u32).wrapping_add(index as u32);
                match size {
                    Size::Byte => self.cpu_read_byte(addr) as u32,
                    Size::Word => self.cpu_read_word(addr) as u32,
                    Size::Long => self.cpu_read_long(addr),
                }
            }
            Operand::Immediate(val) => *val & size.mask(),
        }
    }

    fn set_operand_value(&mut self, size: Size, operand: &Operand, value: u32) {
        match operand {
            Operand::DataRegister(reg) => self.d[*reg as usize] = value & size.mask(),
            Operand::AddressRegister(reg) => self.a[*reg as usize] = value,
            Operand::Indirect(reg) => {
                let addr = self.a[*reg as usize];
                match size {
                    Size::Byte => self.cpu_write_byte(addr, value as u8),
                    Size::Word => self.cpu_write_word(addr, value as u16),
                    Size::Long => self.cpu_write_long(addr, value),
                }
            }
            Operand::PostInc(reg) => {
                let addr = self.a[*reg as usize];
                match size {
                    Size::Byte => self.cpu_write_byte(addr, value as u8),
                    Size::Word => self.cpu_write_word(addr, value as u16),
                    Size::Long => self.cpu_write_long(addr, value),
                }
                self.a[*reg as usize] += size.bits() / 8;
            }
            Operand::PreDec(reg) => {
                self.a[*reg as usize] -= size.bits() / 8;
                let addr = self.a[*reg as usize];
                match size {
                    Size::Byte => self.cpu_write_byte(addr, value as u8),
                    Size::Word => self.cpu_write_word(addr, value as u16),
                    Size::Long => self.cpu_write_long(addr, value),
                }
            }
            Operand::Displacement(reg, disp) => {
                let addr = self.a[*reg as usize].wrapping_add(*disp as u32);
                match size {
                    Size::Byte => self.cpu_write_byte(addr, value as u8),
                    Size::Word => self.cpu_write_word(addr, value as u16),
                    Size::Long => self.cpu_write_long(addr, value),
                }
            }
            Operand::Indexed(reg, disp, idx_reg, idx_size) => {
                let base = self.a[*reg as usize];
                let index = match idx_size {
                    Size::Word => (self.d[*idx_reg as usize] as i16) as i32,
                    Size::Long => self.d[*idx_reg as usize] as i32,
                    _ => unreachable!(),
                };
                let addr = base.wrapping_add(*disp as i32 as u32).wrapping_add(index as u32);
                match size {
                    Size::Byte => self.cpu_write_byte(addr, value as u8),
                    Size::Word => self.cpu_write_word(addr, value as u16),
                    Size::Long => self.cpu_write_long(addr, value),
                }
            }
            Operand::AbsoluteShort(addr) => match size {
                Size::Byte => self.cpu_write_byte(*addr, value as u8),
                Size::Word => self.cpu_write_word(*addr, value as u16),
                Size::Long => self.cpu_write_long(*addr, value),
            },
            Operand::AbsoluteLong(addr) => match size {
                Size::Byte => self.cpu_write_byte(*addr, value as u8),
                Size::Word => self.cpu_write_word(*addr, value as u16),
                Size::Long => self.cpu_write_long(*addr, value),
            },
            _ => panic!("Cannot write to operand: {:?}", operand),
        }
    }

    /// Decode the instruction at the current program counter (PC).
    /// This function fetches the opcode, determines the operation, and
    /// decodes the source and destination operands based on the opcode.
    fn decode(&mut self) -> Instruction {
        let opcode = self.fetch_word();
        if opcode == 0x0000 { // Explicitly handle null opcode
            println!("Null opcode 0x0000 at PC {:06X}", self.pc - 2);
            self.trigger_exception(4);
            return Instruction { operation: Operation::Nop, size: None, src: None, dst: None };
        }
    
        // --- Special fixed opcodes ---
        // RTS
        if opcode == 0x4E75 {
            return Instruction { operation: Operation::Rts, size: None, src: None, dst: None };
        }

        // NOP
        if opcode == 0x4E71 {
            return Instruction { operation: Operation::Nop, size: None, src: None, dst: None };
        }

        // Explicit STOP branch:
        if opcode == 0x4E72 {
            // Read the immediate operand directly from memory to avoid prefetch interference.
            let imm = self.cpu_read_word(self.pc);
            self.pc += 2;
            return Instruction {
                operation: Operation::Stop,
                size: Some(Size::Word),
                src: Some(Operand::Immediate(imm as u32)),
                dst: None,
            };
        }

        // RTE/RESET/TRAPV:
        if (opcode & 0xFFF8) == 0x4E70 {
            let op = match opcode {
                0x4E73 => Operation::Rte,
                0x4E70 => Operation::Reset,
                0x4E76 => Operation::Trapv,
                _      => Operation::Nop,
            };
            return Instruction { operation: op, size: None, src: None, dst: None };
        }

        if (opcode & 0xF000) == 0x4E40 {
            // TRAP instruction (uses lower nibble as vector)
            let vector = (opcode & 0xF) as u32;
            return Instruction { operation: Operation::Trap, size: None, src: Some(Operand::Immediate(vector)), dst: None };
        }

        // MOVEQ – quick move immediate to data register
        if (opcode & 0xF000) == 0x7000 { // MOVEQ
            let reg  = ((opcode >> 9) & 0x7) as u8;
            let data = (opcode & 0xFF) as i8 as i32 as u32;
            return Instruction {
                operation: Operation::Moveq,
                size: Some(Size::Long),
                src: Some(Operand::Immediate(data)),
                dst: Some(Operand::DataRegister(reg)),
            };
        }
    
        // --- Branch instructions (0x6000 range) ---
        if (opcode & 0xF000) == 0x6000 {
            let disp = if (opcode & 0x00FF) == 0 {
                self.fetch_word() as i16 as i32
            } else {
                (opcode & 0x00FF) as i8 as i32
            };
            let op = match opcode & 0x0F00 {
                0x0000 => Operation::Bra,
                0x0200 => Operation::Bhi,
                0x0300 => Operation::Bls,
                0x0400 => Operation::Bcc,
                0x0500 => Operation::Bcs,
                0x0600 => Operation::Bne, // Ensure BNE is correctly mapped
                0x0700 => Operation::Beq,
                0x0800 => Operation::Bvc,
                0x0900 => Operation::Bvs,
                0x0A00 => Operation::Bpl,
                0x0B00 => Operation::Bmi,
                0x0C00 => Operation::Bge,
                0x0D00 => Operation::Blt,
                0x0E00 => Operation::Bgt,
                0x0F00 => Operation::Ble,
                _ => Operation::Nop,
            };
            return Instruction {
                operation: op,
                size: None,
                src: Some(Operand::Immediate(disp as u32)),
                dst: None,
            };
        }
    
        // --- ADD / SUB (Data Register and EA) ---
        if (opcode & 0xF000) == 0xD000 {
            let reg = ((opcode >> 9) & 0x7) as u8;
            let direction = (opcode >> 8) & 0x1; // 0: EA->Dn, 1: Dn->EA
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!("Unexpected size in ADD/SUB: {:#X}", opcode),
            };
            let src_mode = ((opcode >> 3) & 0x7) as u8;
            let src_reg  = (opcode & 0x7) as u8;
            let (src, dst) = if direction == 0 {
                (self.decode_ea(src_mode, src_reg, size), Operand::DataRegister(reg))
            } else {
                (Operand::DataRegister(reg), self.decode_ea(src_mode, src_reg, size))
            };
            let op = if (opcode & 0x1000) != 0 { Operation::Add } else { Operation::Sub };
            return Instruction { operation: op, size: Some(size), src: Some(src), dst: Some(dst) };
        }
    
        // --- MULS (Multiply Signed) ---
        if (opcode & 0xF000) == 0xC000 && (opcode & 0x00F8) == 0x00C0 {
            let size = Size::Word;
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let ea_reg  = (opcode & 0x7) as u8;
            let src = self.decode_ea(ea_mode, ea_reg, size);
            let dn = ((opcode >> 9) & 0x7) as u8;
            return Instruction { operation: Operation::Muls, size: Some(size), src: Some(src), dst: Some(Operand::DataRegister(dn)) };
        }
    
        // --- DIVU (Divide Unsigned) ---
        // Correct DIVU opcode pattern: 1000 ddd0 11mmmrrr
        if (opcode & 0xF1F8) == 0x80C0 {
            let size = Size::Word;
            let dn = ((opcode >> 9) & 0x7) as u8;
            let mode = ((opcode >> 3) & 0x7) as u8;
            let reg = (opcode & 0x7) as u8;
            let src = self.decode_ea(mode, reg, size);
            // Note: Do not check for divide-by-zero here; that belongs in execute.
            return Instruction {
                operation: Operation::Divu,
                size: Some(size),
                src: Some(src),
                dst: Some(Operand::DataRegister(dn)),
            }
        }
    
        // --- MOVE instructions ---
        if (opcode & 0x3000) == 0x1000 {
            let size = match (opcode >> 12) & 0x3 {
                1 => Size::Byte,
                3 => Size::Word,
                2 => Size::Long,
                _ => unreachable!("Unexpected size in MOVE: {:#X}", opcode),
            };
            let dst_reg  = ((opcode >> 9) & 0x7) as u8;
            let dst_mode = ((opcode >> 6) & 0x7) as u8;
            let src_mode = ((opcode >> 3) & 0x7) as u8;
            let src_reg  = (opcode & 0x7) as u8;
            let src = self.decode_ea(src_mode, src_reg, size);
            let mut dst = self.decode_ea(dst_mode, dst_reg, size);
            if size == Size::Byte {
                if let Operand::AddressRegister(reg) = dst {
                    dst = Operand::Indirect(reg);
                }
            }
            return Instruction { operation: Operation::Move, size: Some(size), src: Some(src), dst: Some(dst) };
        }
    
        // --- Immediate arithmetic: ADDI, SUBI, CMPI ---
        if (opcode & 0x0600) == 0x0600 || (opcode & 0x0400) == 0x0400 || (opcode & 0x0C00) == 0x0C00 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let ea_reg  = (opcode & 0x7) as u8;
            let immediate = match size {
                Size::Byte => self.fetch_word() as u32 & 0xFF,
                Size::Word => self.fetch_word() as u32,
                Size::Long => self.fetch_long(),
            };
            let dst = self.decode_ea(ea_mode, ea_reg, size);
            let op = if (opcode & 0x0600) == 0x0600 { Operation::Addi }
                     else if (opcode & 0x0400) == 0x0400 { Operation::Subi }
                     else { Operation::Cmpi };
            return Instruction { operation: op, size: Some(size), src: Some(Operand::Immediate(immediate)), dst: Some(dst) };
        }
    
        // --- Immediate bitwise: EORI, ORI, ANDI ---
        if (opcode & 0xF000) == 0x0000 &&
           ((opcode & 0x0F00) == 0x0A00 ||
            (opcode & 0x0F00) == 0x0000 ||
            (opcode & 0x0F00) == 0x0200) {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let ea_reg  = (opcode & 0x7) as u8;
            let immediate = match size {
                Size::Byte => self.fetch_word() as u32 & 0xFF,
                Size::Word => self.fetch_word() as u32,
                Size::Long => self.fetch_long(),
            };
            let op = if (opcode & 0x0F00) == 0x0A00 { Operation::Eori }
                     else if (opcode & 0x0F00) == 0x0000 { Operation::Ori }
                     else { Operation::Andi };
            return Instruction { operation: op, size: Some(size), src: Some(Operand::Immediate(immediate)), dst: Some(self.decode_ea(ea_mode, ea_reg, size)) };
        }
    
        // --- MOVEP ---
        if (opcode & 0xF138) == 0x0108 {
            let direction = (opcode >> 7) & 0x1;
            let size = if ((opcode >> 6) & 0x1) == 0 { Size::Word } else { Size::Long };
            let dreg = ((opcode >> 9) & 0x7) as u8;
            let areg = (opcode & 0x7) as u8;
            let _disp = self.fetch_word() as i16;
            let (src, dst) = if direction == 0 {
                (self.decode_ea(5, areg, size), Operand::DataRegister(dreg))
            } else {
                (Operand::DataRegister(dreg), self.decode_ea(5, areg, size))
            };
            return Instruction { operation: Operation::Movep, size: Some(size), src: Some(src), dst: Some(dst) };
        }
    
        // --- SWAP / EXT ---
        if (opcode & 0xFF38) == 0x4800 {
            let size = if (opcode & 0x0040) == 0 { Size::Word } else { Size::Long };
            let reg = (opcode & 0x7) as u8;
            let op = if (opcode & 0x00C0) == 0x00C0 { Operation::Ext } else { Operation::Swap };
            return Instruction { operation: op, size: Some(size), src: None, dst: Some(Operand::DataRegister(reg)) };
        }
    
        // --- CLR ---
        if (opcode & 0x4200) == 0x4200 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let ea_reg  = (opcode & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, ea_reg, size);
            return Instruction { operation: Operation::Clr, size: Some(size), src: None, dst: Some(dst) };
        }
    
        // --- TST ---
        if (opcode & 0x4A00) == 0x4A00 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let ea_reg  = (opcode & 0x7) as u8;
            let src = self.decode_ea(ea_mode, ea_reg, size);
            return Instruction { operation: Operation::Tst, size: Some(size), src: Some(src), dst: None };
        }
    
        // --- NEG ---
        if (opcode & 0xF1F8) == 0x4800 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let ea_reg  = (opcode & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, ea_reg, size);
            return Instruction { operation: Operation::Neg, size: Some(size), src: None, dst: Some(dst) };
        }
    
        // --- LSR ---
        if (opcode & 0xF1F8) == 0x4818 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let src = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, Size::Long);
            let dst = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::Lsr, size: Some(size), src: Some(src), dst: Some(dst) };
        }
    
        // --- ASL ---
        if (opcode & 0xF1F8) == 0x4810 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let src = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, Size::Long);
            let dst = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::Asl, size: Some(size), src: Some(src), dst: Some(dst) };
        }
    
        // --- ROR ---
        if (opcode & 0xF1F8) == 0x4818 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let src = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, Size::Long);
            let dst = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::Ror, size: Some(size), src: Some(src), dst: Some(dst) };
        }
    
        // --- ADDX ---
        if (opcode & 0xF108) == 0xC108 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let src = Operand::DataRegister((opcode & 0x7) as u8);
            let dst = Operand::DataRegister(((opcode >> 9) & 0x7) as u8);
            return Instruction { operation: Operation::Addx, size: Some(size), src: Some(src), dst: Some(dst) };
        }
    
        // --- SUBX ---
        if (opcode & 0xF108) == 0x9108 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let src = Operand::DataRegister((opcode & 0x7) as u8);
            let dst = Operand::DataRegister(((opcode >> 9) & 0x7) as u8);
            return Instruction { operation: Operation::Subx, size: Some(size), src: Some(src), dst: Some(dst) };
        }
    
        // --- ADDQ ---
        if (opcode & 0xF100) == 0x5000 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let mut immediate = ((opcode >> 9) & 0x7) as u32;
            if immediate == 0 {
                immediate = 8;
            }
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let ea_reg = (opcode & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, ea_reg, size);
            return Instruction {
                operation: Operation::Addq,
                size: Some(size),
                src: Some(Operand::Immediate(immediate)),
                dst: Some(dst),
            };
        }
    
        // --- SUBQ ---
        if (opcode & 0xF100) == 0x5100 { // SUBQ
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => {
                    println!("Invalid size in SUBQ: {:#X}", opcode);
                    self.trigger_exception(4);
                    return Instruction {
                        operation: Operation::Nop,
                        size: None,
                        src: None,
                        dst: None,
                    };
                }
            };
            let mut immediate = ((opcode >> 9) & 0x7) as u32;
            if immediate == 0 {
                immediate = 8;
            }
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let ea_reg = (opcode & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, ea_reg, size);
            return Instruction {
                operation: Operation::Subq,
                size: Some(size),
                src: Some(Operand::Immediate(immediate)),
                dst: Some(dst),
            };
        }
    
        // --- NOT ---
        if (opcode & 0xF1F8) == 0x4A08 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let ea_reg  = (opcode & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, ea_reg, size);
            return Instruction { operation: Operation::Not, size: Some(size), src: None, dst: Some(dst) };
        }
    
        // --- DIVS ---
        if (opcode & 0xF000) == 0xC000 && (opcode & 0x00F8) == 0x00E8 {
            let size = Size::Word;
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let ea_reg  = (opcode & 0x7) as u8;
            let src = self.decode_ea(ea_mode, ea_reg, size);
            let dn = ((opcode >> 9) & 0x7) as u8;
            return Instruction { operation: Operation::Divs, size: Some(size), src: Some(src), dst: Some(Operand::DataRegister(dn)) };
        }
    
        // --- ROXR ---
        if (opcode & 0xF1F8) == 0x4A18 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let src = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, Size::Long);
            let dst = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::Roxr, size: Some(size), src: Some(src), dst: Some(dst) };
        }
    
        // --- JSR ---
        if (opcode & 0xFF00) == 0x4E80 {
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let ea_reg  = (opcode & 0x7) as u8;
            let src = self.decode_ea(ea_mode, ea_reg, Size::Long);
            return Instruction { operation: Operation::Jsr, size: None, src: Some(src), dst: None };
        }
    
        // --- Bchg ---
        if (opcode & 0x0100) == 0x0100 && (opcode & 0x00C0) == 0x0080 {
            let size = match opcode & 0x0038 {
                0x0000 => Size::Long,
                _      => Size::Byte,
            };
            let dn = ((opcode >> 9) & 0x7) as u8;
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::Bchg, size: Some(size), src: Some(Operand::DataRegister(dn)), dst: Some(dst) };
        }
    
        // --- Bset ---
        if (opcode & 0x0100) == 0x0100 && (opcode & 0x00C0) == 0x0040 {
            let size = match opcode & 0x0038 {
                0x0000 => Size::Long,
                _      => Size::Byte,
            };
            let dn = ((opcode >> 9) & 0x7) as u8;
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::Bset, size: Some(size), src: Some(Operand::DataRegister(dn)), dst: Some(dst) };
        }
    
        // --- Btst ---
        if (opcode & 0x0100) == 0x0100 && (opcode & 0x00C0) == 0x0000 {
            let size = Size::Byte;
            let dn = ((opcode >> 9) & 0x7) as u8;
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::Btst, size: Some(size), src: Some(Operand::DataRegister(dn)), dst: Some(dst) };
        }
    
        // --- LEA ---
        if (opcode & 0xF1C0) == 0x41C0 {
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let src = self.decode_ea(ea_mode, (opcode & 0x7) as u8, Size::Long);
            let an = ((opcode >> 9) & 0x7) as u8;
            return Instruction { operation: Operation::Lea, size: Some(Size::Long), src: Some(src), dst: Some(Operand::AddressRegister(an)) };
        }
    
        // --- CMPA ---
        if (opcode & 0xF1C0) == 0xB1C0 {
            let size = match (opcode >> 6) & 0x3 {
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let src = self.decode_ea(ea_mode, (opcode & 0x7) as u8, size);
            let an = ((opcode >> 9) & 0x7) as u8;
            return Instruction { operation: Operation::Cmpa, size: Some(size), src: Some(src), dst: Some(Operand::AddressRegister(an)) };
        }
    
        // --- CHK ---
        if (opcode & 0xF1C0) == 0x4180 {
            let src = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, Size::Word);
            let an = ((opcode >> 9) & 0x7) as u8;
            return Instruction { operation: Operation::Chk, size: Some(Size::Word), src: Some(src), dst: Some(Operand::AddressRegister(an)) };
        }
    
        // --- TAS (memory variant) ---
        if (opcode & 0xF1F8) == 0x4AFC {
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, (opcode & 0x7) as u8, Size::Byte);
            return Instruction { operation: Operation::TasMem, size: Some(Size::Byte), src: None, dst: Some(dst) };
        }
    
        // --- EXG ---
        if (opcode & 0xF1FF) == 0xC140 {
            let reg1 = ((opcode >> 9) & 0x7) as u8;
            let reg2 = (opcode & 0x7) as u8;
            return Instruction { operation: Operation::Exg, size: None, src: Some(Operand::DataRegister(reg1)), dst: Some(Operand::DataRegister(reg2)) };
        }
    
        // --- MOVEM ---
        if (opcode & 0xFF00) == 0x4880 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Word,
                1 => Size::Long,
                _ => unreachable!(),
            };
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let src = self.decode_ea(ea_mode, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::Movem, size: Some(size), src: Some(src), dst: None };
        }
    
        // --- ASL Mem ---
        if (opcode & 0xF1F8) == 0x4830 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::AslMem, size: Some(size), src: None, dst: Some(dst) };
        }
    
        // --- LSR Mem ---
        if (opcode & 0xF1F8) == 0x4840 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::LsrMem, size: Some(size), src: None, dst: Some(dst) };
        }
    
        // --- CLR Mem ---
        if (opcode & 0xF1F8) == 0x4848 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::ClrMem, size: Some(size), src: None, dst: Some(dst) };
        }
    
        // --- STOP ---
        if opcode == 0x4E72 {
            let imm = self.fetch_word() as u32;
            return Instruction { operation: Operation::Stop, size: Some(Size::Word), src: Some(Operand::Immediate(imm)), dst: None };
        }
    
        // --- RTD ---
        if (opcode & 0xFF00) == 0x4E70 && (opcode & 0x000F) == 0x000E {
            let disp = self.fetch_word() as i16 as i32;
            return Instruction { operation: Operation::Rtd, size: Some(Size::Long), src: Some(Operand::Immediate(disp as u32)), dst: None };
        }
    
        // --- ROL Mem ---
        if (opcode & 0xF1F8) == 0x4860 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::RolMem, size: Some(size), src: None, dst: Some(dst) };
        }
    
        // --- ROR Mem ---
        if (opcode & 0xF1F8) == 0x4870 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let ea_mode = ((opcode >> 3) & 0x7) as u8;
            let dst = self.decode_ea(ea_mode, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::RorMem, size: Some(size), src: None, dst: Some(dst) };
        }
    
        // --- Abcd ---
        if (opcode & 0xF1C0) == 0x8100 {
            let src = self.decode_ea(0, (opcode & 0x7) as u8, Size::Byte);
            let dst = Operand::DataRegister(((opcode >> 9) & 0x7) as u8);
            return Instruction { operation: Operation::Abcd, size: Some(Size::Byte), src: Some(src), dst: Some(dst) };
        }
    
        // --- Sbcd ---
        if (opcode & 0xF1C0) == 0x8108 {
            let src = self.decode_ea(0, (opcode & 0x7) as u8, Size::Byte);
            let dst = Operand::DataRegister(((opcode >> 9) & 0x7) as u8);
            return Instruction { operation: Operation::Sbcd, size: Some(Size::Byte), src: Some(src), dst: Some(dst) };
        }
    
        // --- Nbcd ---
        if (opcode & 0xF1C0) == 0x8110 {
            let dst = Operand::DataRegister(((opcode >> 9) & 0x7) as u8);
            return Instruction { operation: Operation::Nbcd, size: Some(Size::Byte), src: None, dst: Some(dst) };
        }
    
        // --- MOVEA ---
        if (opcode & 0xF1C0) == 0x303C {
            let size = match (opcode >> 6) & 0x3 {
                1 | 2 => Size::Long,
                _ => Size::Word,
            };
            let src = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, size);
            let an = ((opcode >> 9) & 0x7) as u8;
            return Instruction { operation: Operation::Movea, size: Some(Size::Long), src: Some(src), dst: Some(Operand::AddressRegister(an)) };
        }
    
        // --- MOVE CCR / MOVE SR ---
        if (opcode & 0x4600) == 0x4600 {
            let mode = ((opcode >> 3) & 0x7) as u8;
            let src = self.decode_ea(mode, (opcode & 0x7) as u8, Size::Word);
            let op = if opcode >= 0x46C0 && opcode <= 0x46FF { Operation::MoveSr } else { Operation::MoveCcr };
            return Instruction { operation: op, size: Some(Size::Word), src: Some(src), dst: None };
        }
    
        // --- MOVE USP ---
        if (opcode & 0xF1FF) == 0x4E68 {
            let src = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, Size::Long);
            return Instruction { operation: Operation::MoveUsp, size: None, src: Some(src), dst: None };
        }
    
        // --- ANDI/ORI/EORI CCR ---
        if (opcode & 0xFF00) == 0x40C0 {
            let src = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, Size::Byte);
            let op = if (opcode & 0x00C0) == 0x0000 { Operation::OriCcr }
                     else if (opcode & 0x00C0) == 0x0040 { Operation::AndiCcr }
                     else { Operation::EoriCcr };
            return Instruction { operation: op, size: Some(Size::Byte), src: Some(src), dst: None };
        }
    
        // --- ASR ---
        if (opcode & 0xF1F8) == 0x4838 {
            let size = match (opcode >> 6) & 0x3 {
                0 => Size::Byte,
                1 => Size::Word,
                2 => Size::Long,
                _ => unreachable!(),
            };
            let src = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, Size::Long);
            let dst = self.decode_ea(((opcode >> 3) & 0x7) as u8, (opcode & 0x7) as u8, size);
            return Instruction { operation: Operation::Asr, size: Some(size), src: Some(src), dst: Some(dst) };
        }

        // Unimplemented opcodes - Fallback Method to
        if opcode != 0x4E75 && opcode != 0x4E71 && opcode != 0x4E72 && (opcode & 0xFFF8) != 0x4E70 &&
            (opcode & 0xF000) != 0x4E40 && (opcode & 0xF000) != 0x7000 && (opcode & 0xF000) != 0x6000 &&
            (opcode & 0xF000) != 0xD000 && (opcode & 0xF000) != 0xC000 && (opcode & 0xF1F8) != 0x80C0 &&
            (opcode & 0xC000) != 0x0000 && (opcode & 0xF000) != 0x0000 && (opcode & 0xF600) != 0x0600 &&
            (opcode & 0xF138) != 0x0108 && (opcode & 0xF000) != 0x5000 && (opcode & 0xF1C0) != 0x41C0 {
                println!("Unimplemented opcode {:04X} at PC {:06X}", opcode, self.pc - 2);
                self.trigger_exception(4);
                return Instruction { operation: Operation::Nop, size: None, src: None, dst: None };
        }
    
        // --- If no opcode matched, trigger an exception.
        self.trigger_exception(4);
        Instruction { operation: Operation::Nop, size: None, src: None, dst: None }
    }
    

    /// Execute the instruction.
    /// Returns the number of cycles taken by the instruction
    /// and updates the CPU state accordingly.
    fn execute(&mut self, instr: Instruction) -> u32 {
        let mut cycles: u32;
        match instr.operation {
            Operation::Nop => cycles = 4,
            Operation::Rts => {
                self.pc = self.cpu_read_long(self.a[7]);
                self.a[7] += 4;
                cycles = 16;
            }
            Operation::Move => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let value = self.get_operand_value(size, &src);
                self.set_operand_value(size, &dst, value);
                let n = (value & (1 << (size.bits() - 1))) != 0;
                let z = value == 0;
                self.set_flags(n, z, false, false, false);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 8,
                } + self.ea_cycles(&src, size) + self.ea_cycles(&dst, size);
            }
            Operation::Add => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let (result, carry, overflow) = match size {
                    Size::Byte => {
                        let s = src_val as u8;
                        let d = dst_val as u8;
                        let r = s.wrapping_add(d);
                        let c = (s as u16 + d as u16) > 0xFF;
                        let v = ((s & 0x80) == (d & 0x80)) && ((r & 0x80) != (s & 0x80));
                        (r as u32, c, v)
                    }
                    Size::Word => {
                        let s = src_val as u16;
                        let d = dst_val as u16;
                        let r = s.wrapping_add(d);
                        let c = (s as u32 + d as u32) > 0xFFFF;
                        let v = ((s & 0x8000) == (d & 0x8000)) && ((r & 0x8000) != (s & 0x8000));
                        (r as u32, c, v)
                    }
                    Size::Long => {
                        let s = src_val;
                        let d = dst_val;
                        let r = s.wrapping_add(d);
                        let c = (s as u64 + d as u64) > 0xFFFFFFFF;
                        let v = ((s & 0x80000000) == (d & 0x80000000)) && ((r & 0x80000000) != (s & 0x80000000));
                        (r, c, v)
                    }
                };
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                self.set_flags(n, z, overflow, carry, carry);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 8,
                } + self.ea_cycles(&src, size) + if matches!(dst, Operand::DataRegister(_)) {
                    0
                } else {
                    self.ea_cycles(&dst, size)
                };
            }
            Operation::Muls => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src) as i16 as i32;
                let dst_val = self.get_operand_value(size, &dst) as i16 as i32;
                let result = src_val * dst_val;
                self.set_operand_value(Size::Long, &dst, result as u32);
                let n = result < 0;
                let z = result == 0;
                self.set_flags(n, z, false, false, false);
                let _ones = (src_val as u16 as u32 & 0xFFFF).count_ones();
                cycles = 38 + 2 * (src_val as u16).count_ones() + self.ea_cycles(&src, size);
            }
            Operation::Divu => {
                let size = instr.size.unwrap();
                let src = instr.src.as_ref().unwrap();
                let dst = instr.dst.as_ref().unwrap();
            
                // Fetch the 16-bit divisor.
                let divisor = self.get_operand_value(size, src) as u16;
                if divisor == 0 {
                    return self.trigger_exception(5); // Divide by zero.
                }
            
                // Fetch the 32-bit dividend from destination.
                let dividend = self.get_operand_value(Size::Long, dst);
                let quotient = dividend / (divisor as u32);
                let remainder = dividend % (divisor as u32);
            
                // Check if quotient fits in 16 bits.
                if quotient > 0xFFFF {
                    return self.trigger_exception(5); // Division overflow.
                }
            
                // Combine remainder and quotient as per spec: remainder in high word, quotient in low word.
                let result = ((remainder as u32) << 16) | (quotient as u32 & 0xFFFF);
                self.set_operand_value(Size::Long, dst, result);
            
                // Set condition flags.
                let n = (quotient & 0x8000) != 0;
                let z = quotient == 0;
                let v = quotient > 0xFFFF; // This should have been caught, but included for clarity.
                self.set_flags(n, z, v, false, false);
            
                // Initialize cycles with a base value.
                cycles = 76;
            
                // If there is additional cycle adjustment needed:
                if dividend != 0 && divisor != 0 {
                    let quotient_bits = 32 - (dividend / (divisor as u32)).leading_zeros();
                    let shift_count = if quotient_bits > 0 { quotient_bits - 1 } else { 0 };
                    cycles += 2 * shift_count;
                    if dividend < divisor as u32 {
                        cycles += 2;
                    }
                }
                // Include cycles for effective address calculation.
                cycles += self.ea_cycles(src, size);
            }
            Operation::Eor => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let result = src_val ^ dst_val;
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                self.set_flags(n, z, false, false, false);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 8,
                } + self.ea_cycles(&dst, size);
            }
            Operation::Neg => {
                let size = instr.size.unwrap();
                let dst = instr.dst.unwrap();
                let dst_val = self.get_operand_value(size, &dst);
                let result = 0u32.wrapping_sub(dst_val) & size.mask();
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let v = dst_val != 0;
                let c = dst_val != 0;
                self.set_flags(n, z, v, c, c);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 6,
                } + self.ea_cycles(&dst, size);
            }
            Operation::Tst => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let src_val = self.get_operand_value(size, &src);
                let n = (src_val & (1 << (size.bits() - 1))) != 0;
                let z = src_val == 0;
                self.set_flags(n, z, false, false, false);
                cycles = 4 + self.ea_cycles(&src, size);
            }
            Operation::Lsr => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let shift_count = self.get_operand_value(Size::Long, &src) % size.bits();
                let dst_val = self.get_operand_value(size, &dst);
                let result = dst_val >> shift_count;
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let c = if shift_count > 0 {
                    (dst_val >> (shift_count - 1)) & 1 != 0
                } else {
                    false
                };
                self.set_flags(n, z, false, c, c);
                cycles = match size {
                    Size::Byte | Size::Word => 6,
                    Size::Long => 8,
                } + 2 * shift_count as u32;
            }
            Operation::Asl => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let shift_count = self.get_operand_value(Size::Long, &src) % size.bits();
                let dst_val = self.get_operand_value(size, &dst);
                let result = (dst_val << shift_count) & size.mask();
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let c = if shift_count > 0 {
                    (dst_val & (1 << (size.bits() - shift_count))) != 0
                } else {
                    false
                };
                let v = (0..shift_count).any(|i| {
                    let bit = (dst_val >> (size.bits() - 1 - i)) & 1;
                    bit != (dst_val >> (size.bits() - 1)) & 1
                });
                self.set_flags(n, z, v, c, c);
                cycles = match size {
                    Size::Byte | Size::Word => 6,
                    Size::Long => 8,
                } + 2 * shift_count as u32;
            }
            Operation::Moveq => {
                let dst = instr.dst.unwrap();
                let src = instr.src.unwrap();
                let value = self.get_operand_value(Size::Long, &src);
                self.set_operand_value(Size::Long, &dst, value);
                let n = (value & 0x80000000) != 0;
                let z = value == 0;
                self.set_flags(n, z, false, false, false);
                cycles = 4;
            }
            Operation::Ror => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let shift_count = self.get_operand_value(Size::Long, &src) % size.bits();
                let dst_val = self.get_operand_value(size, &dst);
                let mask = (1 << size.bits()) - 1;
                let result = ((dst_val >> shift_count) | (dst_val << (size.bits() - shift_count))) & mask;
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let c = if shift_count > 0 {
                    (dst_val >> (shift_count - 1)) & 1 != 0
                } else {
                    false
                };
                self.set_flags(n, z, false, c, c);
                cycles = match size {
                    Size::Byte | Size::Word => 6,
                    Size::Long => 8,
                } + 2 * shift_count as u32;
            }
            Operation::Eori => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let imm = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let result = imm ^ dst_val;
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                self.set_flags(n, z, false, false, false);
                cycles = match size {
                    Size::Byte | Size::Word => 8,
                    Size::Long => 12,
                } + self.ea_cycles(&dst, size);
            }
            Operation::Cmpi => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let imm = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let result = dst_val.wrapping_sub(imm);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let v = ((dst_val & !imm & !result) | (!dst_val & imm & result)) & (1 << (size.bits() - 1)) != 0;
                let c = ((!dst_val & imm) | (result & !dst_val) | (imm & result)) & (1 << (size.bits() - 1)) != 0;
                self.set_flags(n, z, v, c, c);
                cycles = match size {
                    Size::Byte => 8,
                    Size::Word => 8,
                    Size::Long => 14,
                } + self.ea_cycles(&dst, size);
            }
            Operation::Movep => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                if let Operand::Displacement(areg, disp) = src {
                    let mut addr = self.a[areg as usize].wrapping_add(disp as u32);
                    if let Operand::DataRegister(dreg) = dst {
                        let count = if size == Size::Word {
                            2
                        } else {
                            4
                        };
                        let mut value = 0;
                        for _ in 0..count {
                            value = (value << 8) | (self.cpu_read_byte(addr) as u32);
                            addr += 2;
                        }
                        self.d[dreg as usize] = value;
                    }
                } else if let Operand::DataRegister(dreg) = src {
                    let value = self.d[dreg as usize];
                    if let Operand::Displacement(areg, disp) = dst {
                        let mut addr = self.a[areg as usize].wrapping_add(disp as u32);
                        let count = if size == Size::Word {
                            2
                        } else {
                            4
                        };
                        for i in (0..count).rev() {
                            self.cpu_write_byte(addr, ((value >> (8 * i)) & 0xFF) as u8);
                            addr += 2;
                        }
                    }
                }
                cycles = if size == Size::Word { 16 } else { 24 };
            }
            Operation::Bclr => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let bit_number = self.get_operand_value(Size::Long, &src) % size.bits();
                let dst_val = self.get_operand_value(size, &dst);
                let z = (dst_val & (1 << bit_number)) == 0;
                let result = dst_val & !(1 << bit_number);
                self.set_operand_value(size, &dst, result);
                self.set_flags(false, z, false, false, false);
                cycles = if matches!(dst, Operand::DataRegister(_)) {
                    10
                } else {
                    14
                } + self.ea_cycles(&dst, size);
            }
            Operation::Lea => {
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let addr = match src {
                    Operand::Displacement(reg, disp) => self.a[reg as usize].wrapping_add(disp as u32),
                    Operand::AbsoluteShort(addr) => addr,
                    Operand::AbsoluteLong(addr) => addr,
                    Operand::PCDisplacement(disp) => self.pc.wrapping_add(disp as u32 - 2),
                    _ => panic!("Unsupported addressing mode for LEA: {:?}", src),
                };
                if let Operand::AddressRegister(areg) = dst {
                    self.a[areg as usize] = addr;
                }
                cycles = match src {
                    Operand::Displacement(_, _) => 8,
                    Operand::AbsoluteShort(_) => 8,
                    Operand::AbsoluteLong(_) => 12,
                    Operand::PCDisplacement(_) => 8,
                    _ => 4,
                } + self.ea_cycles(&src, Size::Long);
            }
            Operation::Ext => {
                let size = instr.size.unwrap();
                let dst = instr.dst.unwrap();
                if let Operand::DataRegister(reg) = dst {
                    let value = self.d[reg as usize];
                    let result = if size == Size::Word {
                        ((value as i8) as i32) as u32 & 0xFFFF
                    } else {
                        ((value as i16) as i32) as u32
                    };
                    self.d[reg as usize] = result;
                    let n = (result & (1 << (size.bits() - 1))) != 0;
                    let z = result == 0;
                    self.set_flags(n, z, false, false, false);
                }
                cycles = 4;
            }
            Operation::Sub => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let (result, carry, overflow) = match size {
                    Size::Byte => {
                        let s = src_val as u8;
                        let d = dst_val as u8;
                        let r = d.wrapping_sub(s);
                        let c = (s as u16) > (d as u16);
                        let v = ((d & !s & !r) | (!d & s & r)) & 0x80 != 0;
                        (r as u32, c, v)
                    }
                    Size::Word => {
                        let s = src_val as u16;
                        let d = dst_val as u16;
                        let r = d.wrapping_sub(s);
                        let c = (s as u32) > (d as u32);
                        let v = ((d & !s & !r) | (!d & s & r)) & 0x8000 != 0;
                        (r as u32, c, v)
                    }
                    Size::Long => {
                        let s = src_val;
                        let d = dst_val;
                        let r = d.wrapping_sub(s);
                        let c = (s as u64) > (d as u64);
                        let v = ((d & !s & !r) | (!d & s & r)) & 0x80000000 != 0;
                        (r, c, v)
                    }
                };
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                self.set_flags(n, z, overflow, carry, carry);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 8,
                } + self.ea_cycles(&src, size) + if matches!(dst, Operand::DataRegister(_)) {
                    0
                } else {
                    self.ea_cycles(&dst, size)
                };
            }
            Operation::Andi => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let imm = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let result = imm & dst_val;
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                self.set_flags(n, z, false, false, false);
                cycles = match size {
                    Size::Byte | Size::Word => 8,
                    Size::Long => 14,
                } + self.ea_cycles(&dst, size);
            }
            Operation::Ori => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let imm = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let result = imm | dst_val;
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                self.set_flags(n, z, false, false, false);
                cycles = match size {
                    Size::Byte | Size::Word => 8,
                    Size::Long => 14,
                } + self.ea_cycles(&dst, size);
            }
            Operation::Addx => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let x = (self.sr & 0x1) != 0;
                let (result, carry, overflow) = match size {
                    Size::Byte => {
                        let s = src_val as u8;
                        let d = dst_val as u8;
                        let x_val = if x {
                            1
                        } else {
                            0
                        };
                        let r = d.wrapping_add(s).wrapping_add(x_val);
                        let c = (s as u16 + d as u16 + x_val as u16) > 0xFF;
                        let v = ((s & d & !r) | (!s & !d & r)) & 0x80 != 0;
                        (r as u32, c, v)
                    }
                    Size::Word => {
                        let s = src_val as u16;
                        let d = dst_val as u16;
                        let x_val = if x {
                            1
                        } else {
                            0
                        };
                        let r = d.wrapping_add(s).wrapping_add(x_val);
                        let c = (s as u32 + d as u32 + x_val as u32) > 0xFFFF;
                        let v = ((s & d & !r) | (!s & !d & r)) & 0x8000 != 0;
                        (r as u32, c, v)
                    }
                    Size::Long => {
                        let s = src_val;
                        let d = dst_val;
                        let x_val = if x {
                            1
                        } else {
                            0
                        };
                        let r = d.wrapping_add(s).wrapping_add(x_val);
                        let c = (s as u64 + d as u64 + x_val as u64) > 0xFFFFFFFF;
                        let v = ((s & d & !r) | (!s & !d & r)) & 0x80000000 != 0;
                        (r, c, v)
                    }
                };
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = if self.sr & 0x4 != 0 && result == 0 {
                    true
                } else {
                    false
                };
                self.set_flags(n, z, overflow, carry, carry);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 8,
                } + self.ea_cycles(&src, size) + self.ea_cycles(&dst, size);
            }
            Operation::Subx => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let x = (self.sr & 0x1) != 0;
                let (result, carry, overflow) = match size {
                    Size::Byte => {
                        let s = src_val as u8;
                        let d = dst_val as u8;
                        let x_val = if x {
                            1
                        } else {
                            0
                        };
                        let r = d.wrapping_sub(s).wrapping_sub(x_val);
                        let c = (s as u16 + x_val as u16) > (d as u16);
                        let v = ((d & !s & !r) | (!d & s & r)) & 0x80 != 0;
                        (r as u32, c, v)
                    }
                    Size::Word => {
                        let s = src_val as u16;
                        let d = dst_val as u16;
                        let x_val = if x {
                            1
                        } else {
                            0
                        };
                        let r = d.wrapping_sub(s).wrapping_sub(x_val);
                        let c = (s as u32 + x_val as u32) > (d as u32);
                        let v = ((d & !s & !r) | (!d & s & r)) & 0x8000 != 0;
                        (r as u32, c, v)
                    }
                    Size::Long => {
                        let s = src_val;
                        let d = dst_val;
                        let x_val = if x {
                            1
                        } else {
                            0
                        };
                        let r = d.wrapping_sub(s).wrapping_sub(x_val);
                        let c = (s as u64 + x_val as u64) > (d as u64);
                        let v = ((d & !s & !r) | (!d & s & r)) & 0x80000000 != 0;
                        (r, c, v)
                    }
                };
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = if self.sr & 0x4 != 0 && result == 0 {
                    true
                } else {
                    false
                };
                self.set_flags(n, z, overflow, carry, carry);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 8,
                } + self.ea_cycles(&src, size) + self.ea_cycles(&dst, size);
            }
            Operation::Bra => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                self.pc = ((self.pc as i32 - 2) + disp) as u32; // Adjust PC relative to instruction start
                cycles = 10;
            }
            Operation::Beq => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                if self.sr & 0x4 != 0 { // Zero flag set
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 12; // Branch not taken
                }
            }
            Operation::Bne => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                if self.sr & 0x4 == 0 { // Zero flag clear
                    self.pc = ((self.pc as i32 - 2) + disp) as u32; // Corrected
                    self.prefetch();
                    cycles = 10;
                } else {
                    cycles = 12;
                }
            }
            Operation::Clr => {
                let size = instr.size.unwrap();
                let dst = instr.dst.unwrap();
                self.set_operand_value(size, &dst, 0);
                self.set_flags(false, true, false, false, false);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 6,
                } + self.ea_cycles(&dst, size);
            }
            Operation::Swap => {
                let dst = instr.dst.unwrap();
                if let Operand::DataRegister(reg) = dst {
                    let value = self.d[reg as usize];
                    let result = ((value & 0xFFFF) << 16) | ((value >> 16) & 0xFFFF);
                    self.d[reg as usize] = result;
                    let n = (result & 0x80000000) != 0;
                    let z = result == 0;
                    self.set_flags(n, z, false, false, false);
                }
                cycles = 4;
            }
            Operation::Cmpa => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(Size::Long, &dst);
                let result = dst_val.wrapping_sub(src_val);
                let n = (result & 0x80000000) != 0;
                let z = result == 0;
                let v = ((dst_val & !src_val & !result) | (!dst_val & src_val & result)) & 0x80000000 != 0;
                let c = ((!dst_val & src_val) | (result & (!dst_val | src_val))) & 0x80000000 != 0;
                self.set_flags(n, z, v, c, c);
                cycles = 6 + self.ea_cycles(&src, size);
            }
            Operation::Chk => {
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(Size::Word, &src) as i16;
                let dst_val = self.get_operand_value(Size::Word, &dst) as i16;
                if dst_val < 0 || dst_val > src_val {
                    return self.trigger_exception(6);
                }
                let n = dst_val < 0;
                let z = dst_val == 0;
                self.set_flags(n, z, false, false, false);
                cycles = 10 + self.ea_cycles(&src, Size::Word);
            }
            Operation::Tas => {
                let dst = instr.dst.unwrap();
                let val = self.get_operand_value(Size::Byte, &dst) as u8;
                let n = (val & 0x80) != 0;
                let z = val == 0;
                self.set_flags(n, z, false, false, false);
                self.set_operand_value(Size::Byte, &dst, (val | 0x80) as u32);
                cycles = if matches!(dst, Operand::DataRegister(_)) {
                    4
                } else {
                    14
                } + self.ea_cycles(&dst, Size::Byte);
            }
            Operation::Rol => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let shift_count = self.get_operand_value(Size::Long, &src) % size.bits();
                let dst_val = self.get_operand_value(size, &dst);
                let result = dst_val.rotate_left(shift_count);
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let c = if shift_count > 0 {
                    (dst_val & (1 << (size.bits() - shift_count))) != 0
                } else {
                    false
                };
                self.set_flags(n, z, false, c, c);
                cycles = match size {
                    Size::Byte | Size::Word => 6,
                    Size::Long => 8,
                } + 2 * shift_count as u32;
            }
            Operation::Roxl => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let shift_count = self.get_operand_value(Size::Long, &src) % (size.bits() + 1);
                let dst_val = self.get_operand_value(size, &dst);
                let x = (self.sr & 0x1) != 0;
                let shift = size.bits();
                let full_val = if x {
                    dst_val | (1 << shift)
                } else {
                    dst_val
                };
                let result = if shift_count == 0 {
                    dst_val
                } else {
                    full_val.rotate_left(shift_count) & size.mask()
                };
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (shift - 1))) != 0;
                let z = result == 0;
                let c = if shift_count > 0 {
                    (full_val & (1 << (shift + 1 - shift_count))) != 0
                } else {
                    false
                };
                self.set_flags(n, z, false, c, c);
                self.sr = (self.sr & 0xFFFE) | (if c {
                    1
                } else {
                    0
                });
                cycles = match size {
                    Size::Byte | Size::Word => 6,
                    Size::Long => 8,
                } + 2 * shift_count as u32;
            }
            Operation::Jsr => {
                let src = instr.src.unwrap();
                let addr = self.get_operand_value(Size::Long, &src);
                self.a[7] -= 4;
                self.cpu_write_long(self.a[7], self.pc);
                self.pc = addr;
                cycles = match src {
                    Operand::Displacement(_, _) => 18,
                    Operand::AbsoluteShort(_) => 18,
                    Operand::AbsoluteLong(_) => 20,
                    _ => 16,
                } + self.ea_cycles(&src, Size::Long);
            }
            Operation::Bchg => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let bit_num = self.get_operand_value(Size::Long, &src) % size.bits();
                let val = self.get_operand_value(size, &dst);
                let z = (val & (1 << bit_num)) == 0;
                let result = val ^ (1 << bit_num);
                self.set_operand_value(size, &dst, result);
                self.set_flags(false, z, false, false, false);
                cycles = if matches!(dst, Operand::DataRegister(_)) {
                    8
                } else {
                    12
                } + self.ea_cycles(&dst, size);
            }
            Operation::Bset => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let bit_num = self.get_operand_value(Size::Long, &src) % size.bits();
                let val = self.get_operand_value(size, &dst);
                let z = (val & (1 << bit_num)) == 0;
                let result = val | (1 << bit_num);
                self.set_operand_value(size, &dst, result);
                self.set_flags(false, z, false, false, false);
                cycles = if matches!(dst, Operand::DataRegister(_)) {
                    8
                } else {
                    12
                } + self.ea_cycles(&dst, size);
            }
            Operation::Btst => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let bit_num = self.get_operand_value(Size::Long, &src) % size.bits();
                let val = self.get_operand_value(size, &dst);
                let z = (val & (1 << bit_num)) == 0;
                self.set_flags(false, z, false, false, false);
                cycles = if matches!(dst, Operand::DataRegister(_)) {
                    6
                } else {
                    4
                } + self.ea_cycles(&dst, size);
            }
            Operation::Trap => {
                let vector = self.get_operand_value(Size::Long, &instr.src.unwrap());
                self.a[7] -= 4;
                self.cpu_write_long(self.a[7], self.pc);
                self.a[7] -= 2;
                self.cpu_write_word(self.a[7], self.sr);
                self.pc = self.cpu_read_long(32 + vector * 4);
                self.prefetch();
                cycles = 34;
            }
            Operation::And => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let result = src_val & dst_val;
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                self.set_flags(n, z, false, false, false);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 6,
                } + self.ea_cycles(&src, size) + if matches!(dst, Operand::DataRegister(_)) {
                    0
                } else {
                    self.ea_cycles(&dst, size)
                };
            }
            Operation::Or => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let result = src_val | dst_val;
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                self.set_flags(n, z, false, false, false);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 6,
                } + self.ea_cycles(&src, size) + if matches!(dst, Operand::DataRegister(_)) {
                    0
                } else {
                    self.ea_cycles(&dst, size)
                };
            }
            Operation::Addq => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let (result, carry, overflow) = match size {
                    Size::Byte => {
                        let s = src_val as u8;
                        let d = dst_val as u8;
                        let r = d.wrapping_add(s);
                        let c = (s as u16 + d as u16) > 0xFF;
                        let v = ((s & d & !r) | (!s & !d & r)) & 0x80 != 0;
                        (r as u32, c, v)
                    }
                    Size::Word => {
                        let s = src_val as u16;
                        let d = dst_val as u16;
                        let r = d.wrapping_add(s);
                        let c = (s as u32 + d as u32) > 0xFFFF;
                        let v = ((s & d & !r) | (!s & !d & r)) & 0x8000 != 0;
                        (r as u32, c, v)
                    }
                    Size::Long => {
                        let s = src_val;
                        let d = dst_val;
                        let r = d.wrapping_add(s);
                        let c = (s as u64 + d as u64) > 0xFFFFFFFF;
                        let v = ((s & d & !r) | (!s & !d & r)) & 0x80000000 != 0;
                        (r, c, v)
                    }
                };
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                self.set_flags(n, z, overflow, carry, carry);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 8,
                } + self.ea_cycles(&dst, size);
            }
            Operation::Subq => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let mut imm = self.get_operand_value(size, &src);
                if imm == 0 {
                    imm = 8;
                }
                let dst_val = self.get_operand_value(size, &dst);
                let result = dst_val.wrapping_sub(imm) & size.mask();
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                self.set_flags(n, z, false, false, false);
                cycles = match size {
                    Size::Byte | Size::Word => 8, // Corrected to 8 for register
                    Size::Long => 12,
                } + self.ea_cycles(&dst, size);
            }
            Operation::Not => {
                let size = instr.size.unwrap();
                let dst = instr.dst.unwrap();
                let val = self.get_operand_value(size, &dst);
                let result = (!val) & size.mask();
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                self.set_flags(n, z, false, false, false);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 6,
                } + self.ea_cycles(&dst, size);
            }
            Operation::Divs => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let divisor = self.get_operand_value(size, &src) as i16 as i32;
                let dividend = self.get_operand_value(Size::Long, &dst) as i32;
                if divisor == 0 {
                    return self.trigger_exception(5);
                }
                let quotient = dividend / divisor;
                let remainder = dividend % divisor;
                let result = ((remainder as u32) << 16) | (quotient as u32 & 0xFFFF);
                self.set_operand_value(Size::Long, &dst, result);
                let n = (quotient & 0x8000) != 0;
                let z = quotient == 0;
                let v = quotient > 0x7FFF || quotient < -0x8000;
                self.set_flags(n, z, v, false, false);
                cycles = 96;
                if dividend != 0 && divisor != 0 {
                    let quotient_abs = quotient.abs() as u32;
                    let quotient_bits = 32 - quotient_abs.leading_zeros();
                    let shift_count = if quotient_bits > 0 {
                        quotient_bits - 1
                    } else {
                        0
                    };
                    cycles += 2 * shift_count;
                    if dividend < 0 {
                        cycles += 2;
                    }
                    if divisor < 0 {
                        cycles += 2;
                    }
                    if quotient_abs == 0 && (dividend < 0 || divisor < 0) {
                        cycles += 4;
                    }
                }
                cycles += self.ea_cycles(&src, size);
            }
            Operation::Roxr => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let shift_count = self.get_operand_value(Size::Long, &src) % (size.bits() + 1);
                let dst_val = self.get_operand_value(size, &dst);
                let x = (self.sr & 0x1) != 0;
                let shift = size.bits();
                let full_val = if x {
                    dst_val | (1 << shift)
                } else {
                    dst_val
                };
                let result = if shift_count == 0 {
                    dst_val
                } else {
                    full_val.rotate_right(shift_count) & size.mask()
                };
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (shift - 1))) != 0;
                let z = result == 0;
                let c = if shift_count > 0 {
                    (full_val & (1 << (shift_count - 1))) != 0
                } else {
                    false
                };
                self.set_flags(n, z, false, c, c);
                self.sr = (self.sr & 0xFFFE) | (if c {
                    1
                } else {
                    0
                });
                cycles = match size {
                    Size::Byte | Size::Word => 6,
                    Size::Long => 8,
                } + 2 * shift_count as u32;
            }
            Operation::Bhi => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                let z = (self.sr & 0x4) != 0;
                let c = (self.sr & 0x1) != 0;
                if !c && !z {
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 12;
                }
            }
            Operation::Bls => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                let z = (self.sr & 0x4) != 0;
                let c = (self.sr & 0x1) != 0;
                if c || z {
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 12;
                }
            }
            Operation::Jmp => {
                let src = instr.src.unwrap();
                let addr = self.get_operand_value(Size::Long, &src);
                self.pc = addr;
                self.prefetch();
                cycles = match src {
                    Operand::Displacement(_, _) => 10,
                    Operand::AbsoluteShort(_) => 10,
                    Operand::AbsoluteLong(_) => 12,
                    _ => 8,
                } + self.ea_cycles(&src, Size::Long);
            }
            Operation::Adda => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src) as i32 as u32;
                let dst_val = self.get_operand_value(Size::Long, &dst);
                let result = dst_val.wrapping_add(src_val);
                self.set_operand_value(Size::Long, &dst, result);
                cycles = match size {
                    Size::Word => 8,
                    Size::Long => 6,
                    Size::Byte => 8,
                } + self.ea_cycles(&src, size);
            }
            Operation::Suba => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src) as i32 as u32;
                let dst_val = self.get_operand_value(Size::Long, &dst);
                let result = dst_val.wrapping_sub(src_val);
                self.set_operand_value(Size::Long, &dst, result);
                cycles = match size {
                    Size::Word => 8,
                    Size::Long => 6,
                    Size::Byte => 8,
                } + self.ea_cycles(&src, size);
            }
            Operation::Mulu => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src) as u16 as u32;
                let dst_val = self.get_operand_value(size, &dst) as u16 as u32;
                let result = src_val * dst_val;
                self.set_operand_value(Size::Long, &dst, result);
                let n = (result & 0x80000000) != 0;
                let z = result == 0;
                self.set_flags(n, z, false, false, false);
                let ones = src_val.count_ones();
                cycles = 38 + 2 * ones + self.ea_cycles(&src, size);
            }
            Operation::Cmp => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let result = dst_val.wrapping_sub(src_val);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let v = ((dst_val & !src_val & !result) | (!dst_val & src_val & result)) & (1 << (size.bits() - 1)) != 0;
                let c = ((!dst_val & src_val) | (result & (!dst_val | src_val))) & (1 << (size.bits() - 1)) != 0;
                self.set_flags(n, z, v, c, c);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 6,
                } + self.ea_cycles(&src, size);
            }
            Operation::Scc => {
                let dst = instr.dst.unwrap();
                let carry = (self.sr & 0x1) != 0;
                let value = if !carry {
                    0xFF
                } else {
                    0x00
                };
                self.set_operand_value(Size::Byte, &dst, value as u32);
                cycles = if matches!(dst, Operand::DataRegister(_)) {
                    4
                } else {
                    8
                } + self.ea_cycles(&dst, Size::Byte);
            }
            Operation::Dbcc => {
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let dn_val = self.get_operand_value(Size::Word, &src);
                let disp = self.get_operand_value(Size::Long, &dst) as i32;
                let new_val = dn_val.wrapping_sub(1) & 0xFFFF;
                self.set_operand_value(Size::Word, &src, new_val);
                let c = (self.sr & 0x1) != 0;
                if !c && new_val != 0xFFFF {
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 14;
                }
            }
            Operation::Pea => {
                let src = instr.src.unwrap();
                let addr = match src {
                    Operand::Displacement(reg, disp) => self.a[reg as usize].wrapping_add(disp as u32),
                    Operand::AbsoluteShort(addr) => addr,
                    Operand::AbsoluteLong(addr) => addr,
                    Operand::PCDisplacement(disp) => self.pc.wrapping_add(disp as u32 - 2),
                    _ => panic!("Unsupported addressing mode for PEA: {:?}", src),
                };
                self.a[7] -= 4;
                self.cpu_write_long(self.a[7], addr);
                cycles = match src {
                    Operand::Displacement(_, _) => 12,
                    Operand::AbsoluteShort(_) => 12,
                    Operand::AbsoluteLong(_) => 16,
                    _ => 12,
                } + self.ea_cycles(&src, Size::Long);
            }
            Operation::Link => {
                let an = instr.dst.unwrap();
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                if let Operand::AddressRegister(reg) = an {
                    self.a[7] -= 4;
                    self.cpu_write_long(self.a[7], self.a[reg as usize]);
                    self.a[reg as usize] = self.a[7];
                    self.a[7] = (self.a[7] as i32 + disp) as u32;
                }
                cycles = 16;
            }
            Operation::Unlk => {
                let an = instr.dst.unwrap();
                if let Operand::AddressRegister(reg) = an {
                    self.a[7] = self.a[reg as usize];
                    self.a[reg as usize] = self.cpu_read_long(self.a[7]);
                    self.a[7] += 4;
                }
                cycles = 12;
            }
            Operation::NopAlt => {
                cycles = 4;
            }
            Operation::Bgt => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                let z = (self.sr & 0x4) != 0;
                let n = (self.sr & 0x8) != 0;
                let v = (self.sr & 0x2) != 0;
                if !z && (n == v) {
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 12;
                }
            }
            Operation::Ble => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                let z = (self.sr & 0x4) != 0;
                let n = (self.sr & 0x8) != 0;
                let v = (self.sr & 0x2) != 0;
                if z || (n != v) {
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 12;
                }
            }
            Operation::Exg => {
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                if let (Operand::DataRegister(rx), Operand::DataRegister(ry)) = (src, dst) {
                    let temp = self.d[rx as usize];
                    self.d[rx as usize] = self.d[ry as usize];
                    self.d[ry as usize] = temp;
                }
                cycles = 6;
            }
            Operation::Movem => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let reglist = self.get_operand_value(Size::Long, &src) as u16;
                let mut addr = match dst {
                    Operand::Indirect(reg) => self.a[reg as usize],
                    Operand::Displacement(reg, disp) => self.a[reg as usize].wrapping_add(disp as u32),
                    _ => match src {
                        Operand::Indirect(reg) => self.a[reg as usize],
                        Operand::Displacement(reg, disp) => self.a[reg as usize].wrapping_add(disp as u32),
                        _ => panic!("Unsupported MOVEM addressing mode"),
                    },
                };
                cycles = 12 + self.ea_cycles(&src, size);
                let mut bit = 0;
                let regs = reglist.count_ones();
                if let Operand::Immediate(_) = src {
                    for i in 0..16 {
                        if (reglist & (1 << bit)) != 0 {
                            let value = if i < 8 {
                                self.d[i]
                            } else {
                                self.a[i - 8]
                            };
                            if size == Size::Word {
                                self.cpu_write_word(addr, value as u16);
                                addr += 2;
                                cycles += 4;
                            } else {
                                self.cpu_write_long(addr, value);
                                addr += 4;
                                cycles += 8;
                            }
                        }
                        bit += 1;
                    }
                } else {
                    for i in 0..16 {
                        if (reglist & (1 << bit)) != 0 {
                            let value = if size == Size::Word {
                                let val = self.cpu_read_word(addr) as u32;
                                addr += 2;
                                cycles += 4;
                                val
                            } else {
                                let val = self.cpu_read_long(addr);
                                addr += 4;
                                cycles += 8;
                                val
                            };
                            if i < 8 {
                                self.d[i] = value;
                            } else {
                                self.a[i - 8] = value;
                            }
                        }
                        bit += 1;
                    }
                }
                cycles = 12 + (if size == Size::Word {
                    4
                } else {
                    8
                } * regs);
            }
            Operation::AslMem => {
                let size = instr.size.unwrap();
                let dst = instr.dst.unwrap();
                let dst_val = self.get_operand_value(size, &dst);
                let result = (dst_val << 1) & size.mask();
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let c = (dst_val & (1 << (size.bits() - 1))) != 0;
                let v = (dst_val & (1 << (size.bits() - 1))) != (result & (1 << (size.bits() - 1)));
                self.set_flags(n, z, v, c, c);
                cycles = 8 + self.ea_cycles(&dst, size);
            }
            Operation::LsrMem => {
                let size = instr.size.unwrap();
                let dst = instr.dst.unwrap();
                let dst_val = self.get_operand_value(size, &dst);
                let result = dst_val >> 1;
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let c = (dst_val & 1) != 0;
                self.set_flags(n, z, false, c, c);
                cycles = 8 + self.ea_cycles(&dst, size);
            }
            Operation::ClrMem => {
                let size = instr.size.unwrap();
                let dst = instr.dst.unwrap();
                self.set_operand_value(size, &dst, 0);
                self.set_flags(false, true, false, false, false);
                cycles = match size {
                    Size::Byte | Size::Word => 4,
                    Size::Long => 6,
                } + self.ea_cycles(&dst, size);
            }
            Operation::Stop => {
                if !self.check_supervisor() {
                    // In user mode, STOP is a privileged instruction.
                    // Trigger a privilege violation exception (typically vector 8).
                    return self.trigger_exception(8);
                } else {
                    let data = self.get_operand_value(Size::Word, &instr.src.unwrap()) as u16;
                    self.sr = data;
                    self.halted = true;
                    cycles = 4;
                }
            }
            Operation::Rtd => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                self.pc = self.cpu_read_long(self.a[7]);
                self.a[7] += 4 + disp as u32;
                self.prefetch();
                cycles = 16;
            }
            Operation::TasMem => {
                let dst = instr.dst.unwrap();
                let val = self.get_operand_value(Size::Byte, &dst) as u8;
                let n = (val & 0x80) != 0;
                let z = val == 0;
                self.set_flags(n, z, false, false, false);
                self.set_operand_value(Size::Byte, &dst, (val | 0x80) as u32);
                cycles = if matches!(dst, Operand::DataRegister(_)) {
                    4
                } else {
                    14
                } + self.ea_cycles(&dst, Size::Byte);
            }
            Operation::Bcc => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                if (self.sr & 0x1) == 0 {
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 12;
                }
            }
            Operation::Bcs => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                if (self.sr & 0x1) != 0 {
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 12;
                }
            }
            Operation::Bge => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                let n = (self.sr & 0x8) != 0;
                let v = (self.sr & 0x2) != 0;
                if n == v {
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 12;
                }
            }
            Operation::Blt => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                let n = (self.sr & 0x8) != 0;
                let v = (self.sr & 0x2) != 0;
                if n != v {
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 12;
                }
            }
            Operation::Bmi => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                if (self.sr & 0x8) != 0 {
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 12;
                }
            }
            Operation::Bpl => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                if (self.sr & 0x8) == 0 {
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 12;
                }
            }
            Operation::Lsl => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let shift_count = self.get_operand_value(Size::Long, &src) % size.bits();
                let dst_val = self.get_operand_value(size, &dst);
                let result = (dst_val << shift_count) & size.mask();
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let c = if shift_count > 0 {
                    (dst_val & (1 << (size.bits() - shift_count))) != 0
                } else {
                    false
                };
                self.set_flags(n, z, false, c, c);
                cycles = match size {
                    Size::Byte | Size::Word => 6,
                    Size::Long => 8,
                } + 2 * shift_count as u32;
            }
            Operation::RolMem => {
                let size = instr.size.unwrap();
                let dst = instr.dst.unwrap();
                let dst_val = self.get_operand_value(size, &dst);
                let result = dst_val.rotate_left(1) & size.mask();
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let c = (dst_val & (1 << (size.bits() - 1))) != 0;
                self.set_flags(n, z, false, c, c);
                cycles = 8 + self.ea_cycles(&dst, size);
            }
            Operation::RorMem => {
                let size = instr.size.unwrap();
                let dst = instr.dst.unwrap();
                let dst_val = self.get_operand_value(size, &dst);
                let result = dst_val.rotate_right(1) & size.mask();
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let c = (dst_val & 1) != 0;
                self.set_flags(n, z, false, c, c);
                cycles = 8 + self.ea_cycles(&dst, size);
            }
            Operation::Subi => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let imm = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let (result, carry, overflow) = match size {
                    Size::Byte => {
                        let s = imm as u8;
                        let d = dst_val as u8;
                        let r = d.wrapping_sub(s);
                        let c = s > d;
                        let v = ((d & !s & !r) | (!d & s & r)) & 0x80 != 0;
                        (r as u32, c, v)
                    }
                    Size::Word => {
                        let s = imm as u16;
                        let d = dst_val as u16;
                        let r = d.wrapping_sub(s);
                        let c = s > d;
                        let v = ((d & !s & !r) | (!d & s & r)) & 0x8000 != 0;
                        (r as u32, c, v)
                    }
                    Size::Long => {
                        let s = imm;
                        let d = dst_val;
                        let r = d.wrapping_sub(s);
                        let c = s > d;
                        let v = ((d & !s & !r) | (!d & s & r)) & 0x80000000 != 0;
                        (r, c, v)
                    }
                };
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                self.set_flags(n, z, overflow, carry, carry);
                cycles = match size {
                    Size::Byte | Size::Word => 8,
                    Size::Long => 14,
                } + self.ea_cycles(&dst, size);
            }
            Operation::Abcd => {
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(Size::Byte, &src) as u8;
                let dst_val = self.get_operand_value(Size::Byte, &dst) as u8;
                let x = (self.sr & 0x1) != 0;
                let tens = ((src_val >> 4) & 0xF) + ((dst_val >> 4) & 0xF) + (if x {
                    1
                } else {
                    0
                });
                let units = (src_val & 0xF) + (dst_val & 0xF);
                let mut result = (units % 10) | (((tens + (units / 10)) % 10) << 4);
                let c = tens > 9 || units > 9;
                if result == 0 {
                    result = 0x00;
                }
                self.set_operand_value(Size::Byte, &dst, result as u32);
                let n = (result & 0x80) != 0;
                let z = if self.sr & 0x4 != 0 && result == 0 {
                    true
                } else {
                    false
                };
                self.set_flags(n, z, false, c, c);
                cycles = if matches!(src, Operand::DataRegister(_)) {
                    6
                } else {
                    18
                };
            }
            Operation::Sbcd => {
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let src_val = self.get_operand_value(Size::Byte, &src) as u8;
                let dst_val = self.get_operand_value(Size::Byte, &dst) as u8;
                let x = (self.sr & 0x1) != 0;
                let src_dec = ((src_val >> 4) & 0xF) * 10 + (src_val & 0xF);
                let dst_dec = ((dst_val >> 4) & 0xF) * 10 + (dst_val & 0xF);
                let diff = (dst_dec as i16) - (src_dec as i16) - (if x {
                    1
                } else {
                    0
                });
                let result = if diff < 0 {
                    (100 + diff) as u8
                } else {
                    diff as u8
                };
                let result_bcd = ((result / 10) << 4) | (result % 10);
                self.set_operand_value(Size::Byte, &dst, result_bcd as u32);
                let n = (result_bcd & 0x80) != 0;
                let z = if self.sr & 0x4 != 0 && result_bcd == 0 {
                    true
                } else {
                    false
                };
                let c = diff < 0;
                self.set_flags(n, z, false, c, c);
                cycles = if matches!(src, Operand::DataRegister(_)) {
                    6
                } else {
                    18
                };
            }
            Operation::Nbcd => {
                let dst = instr.dst.unwrap();
                let dst_val = self.get_operand_value(Size::Byte, &dst) as u8;
                let x = (self.sr & 0x1) != 0;
                let dec_val = ((dst_val >> 4) & 0xF) * 10 + (dst_val & 0xF);
                let result_dec: i16 = (0 - dec_val - (if x {
                    1
                } else {
                    0
                })).into();
                let result = if result_dec < 0 {
                    (100 + result_dec) as u8
                } else {
                    result_dec as u8
                };
                let result_bcd = ((result / 10) << 4) | (result % 10);
                self.set_operand_value(Size::Byte, &dst, result_bcd as u32);
                let n = (result_bcd & 0x80) != 0;
                let z = if self.sr & 0x4 != 0 && result_bcd == 0 {
                    true
                } else {
                    false
                };
                let c = result_dec != 0;
                self.set_flags(n, z, false, c, c);
                cycles = if matches!(dst, Operand::DataRegister(_)) {
                    6
                } else {
                    8
                };
            }
            Operation::Addi => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let imm = self.get_operand_value(size, &src);
                let dst_val = self.get_operand_value(size, &dst);
                let (result, carry, overflow) = match size {
                    Size::Byte => {
                        let s = imm as u8;
                        let d = dst_val as u8;
                        let r = d.wrapping_add(s);
                        let c = (s as u16 + d as u16) > 0xFF;
                        let v = ((s & d & !r) | (!s & !d & r)) & 0x80 != 0;
                        (r as u32, c, v)
                    }
                    Size::Word => {
                        let s = imm as u16;
                        let d = dst_val as u16;
                        let r = d.wrapping_add(s);
                        let c = (s as u32 + d as u32) > 0xFFFF;
                        let v = ((s & d & !r) | (!s & !d & r)) & 0x8000 != 0;
                        (r as u32, c, v)
                    }
                    Size::Long => {
                        let s = imm;
                        let d = dst_val;
                        let r = d.wrapping_add(s);
                        let c = (s as u64 + d as u64) > 0xFFFFFFFF;
                        let v = ((s & d & !r) | (!s & !d & r)) & 0x80000000 != 0;
                        (r, c, v)
                    }
                };
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                self.set_flags(n, z, overflow, carry, carry);
                cycles = match size {
                    Size::Byte | Size::Word => 8,
                    Size::Long => 14,
                } + self.ea_cycles(&dst, size);
            }
            Operation::Bvc => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                if (self.sr & 0x2) == 0 {
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 12;
                }
            }
            Operation::Bvs => {
                let disp = self.get_operand_value(Size::Long, &instr.src.unwrap()) as i32;
                if (self.sr & 0x2) != 0 {
                    self.pc = ((self.pc as i32 - 2) + disp) as u32;
                    cycles = 10;
                } else {
                    cycles = 12;
                }
            }
            Operation::RoxlMem => {
                let size = instr.size.unwrap();
                let dst = instr.dst.unwrap();
                let dst_val = self.get_operand_value(size, &dst);
                let x = (self.sr & 0x1) != 0;
                let shift = size.bits();
                let full_val = if x {
                    dst_val | (1 << shift)
                } else {
                    dst_val
                };
                let result = full_val.rotate_left(1) & size.mask();
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let c = (dst_val & (1 << (size.bits() - 1))) != 0;
                self.set_flags(n, z, false, c, c);
                self.sr = (self.sr & 0xFFFE) | (if c {
                    1
                } else {
                    0
                });
                cycles = 8 + self.ea_cycles(&dst, size);
            }
            Operation::RoxrMem => {
                let size = instr.size.unwrap();
                let dst = instr.dst.unwrap();
                let dst_val = self.get_operand_value(size, &dst);
                let x = (self.sr & 0x1) != 0;
                let shift = size.bits();
                let full_val = if x {
                    dst_val | (1 << shift)
                } else {
                    dst_val
                };
                let result = full_val.rotate_right(1) & size.mask();
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let c = (dst_val & 1) != 0;
                self.set_flags(n, z, false, c, c);
                self.sr = (self.sr & 0xFFFE) | (if c {
                    1
                } else {
                    0
                });
                cycles = 8 + self.ea_cycles(&dst, size);
            }
            Operation::Trapv => {
                if (self.sr & 0x2) != 0 {
                    cycles = self.trigger_exception(7);
                } else {
                    cycles = 4;
                }
            }
            Operation::Reset => {
                if !self.check_supervisor() {
                    cycles = 34;
                } else {
                    self.pc = self.cpu_read_long(4);
                    self.sr = 0x2700;
                    self.d = [0; 8];
                    self.a = [0; 8];
                    self.a[7] = self.cpu_read_long(0);
                    self.prefetch();
                    cycles = 132;
                }
            }
            Operation::Rte => {
                if !self.check_supervisor() {
                    cycles = 34;
                } else {
                    self.sr = self.cpu_read_word(self.a[7]);
                    self.a[7] += 2;
                    self.pc = self.cpu_read_long(self.a[7]);
                    self.a[7] += 4;
                    self.interrupt_nest_level = self.interrupt_nest_level.saturating_sub(1);
                    self.prefetch();
                    cycles = 20;
                }
            }
            Operation::Movea => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let value = self.get_operand_value(size, &src);
                self.set_operand_value(Size::Long, &dst, value);
                cycles = match size {
                    Size::Word => 4,
                    Size::Long => 4,
                    Size::Byte => 4,
                } + self.ea_cycles(&src, size);
            }
            Operation::MoveCcr => {
                let src = instr.src.unwrap();
                let value = self.get_operand_value(Size::Byte, &src) as u16;
                self.sr = (self.sr & 0xFF00) | (value & 0x1F);
                cycles = 12 + self.ea_cycles(&src, Size::Byte);
            }
            Operation::MoveSr => {
                if !self.check_supervisor() {
                    cycles = 34;
                } else {
                    let src = instr.src.unwrap();
                    let value = self.get_operand_value(Size::Word, &src) as u16;
                    self.sr = value;
                    cycles = 12 + self.ea_cycles(&src, Size::Word);
                }
            }
            Operation::MoveUsp => {
                if !self.check_supervisor() {
                    cycles = 34;
                } else {
                    let src = instr.src.unwrap();
                    let dst = instr.dst.unwrap();
                    if let Operand::AddressRegister(an) = src {
                        self.a[7] = self.a[an as usize];
                    } else if let Operand::AddressRegister(an) = dst {
                        self.a[an as usize] = self.a[7];
                    }
                    cycles = 4;
                }
            }
            Operation::AndiCcr => {
                if !self.check_supervisor() {
                    cycles = 34;
                } else {
                    let src = instr.src.unwrap();
                    let value = self.get_operand_value(Size::Byte, &src) as u16;
                    self.sr = (self.sr & 0xFF00) | ((self.sr & 0x1F) & (value & 0x1F));
                    cycles = 20;
                }
            }
            Operation::OriCcr => {
                if !self.check_supervisor() {
                    cycles = 34;
                } else {
                    let src = instr.src.unwrap();
                    let value = self.get_operand_value(Size::Byte, &src) as u16;
                    self.sr = (self.sr & 0xFF00) | ((self.sr & 0x1F) | (value & 0x1F));
                    cycles = 20;
                }
            }
            Operation::EoriCcr => {
                if !self.check_supervisor() {
                    cycles = 34;
                } else {
                    let src = instr.src.unwrap();
                    let value = self.get_operand_value(Size::Byte, &src) as u16;
                    self.sr = (self.sr & 0xFF00) | ((self.sr & 0x1F) ^ (value & 0x1F));
                    cycles = 20;
                }
            }
            Operation::LslMem => {
                let size = instr.size.unwrap();
                let dst = instr.dst.unwrap();
                let dst_val = self.get_operand_value(size, &dst);
                let result = (dst_val << 1) & size.mask();
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let c = (dst_val & (1 << (size.bits() - 1))) != 0;
                self.set_flags(n, z, false, c, c);
                cycles = 8 + self.ea_cycles(&dst, size);
            }
            Operation::Asr => {
                let size = instr.size.unwrap();
                let src = instr.src.unwrap();
                let dst = instr.dst.unwrap();
                let shift_count = self.get_operand_value(Size::Long, &src) % size.bits();
                let dst_val = self.get_operand_value(size, &dst) as i32;
                let result = match size {
                    Size::Byte => (dst_val as i8 >> shift_count) as u32 & 0xFF,
                    Size::Word => (dst_val as i16 >> shift_count) as u32 & 0xFFFF,
                    Size::Long => (dst_val >> shift_count) as u32,
                };
                self.set_operand_value(size, &dst, result);
                let n = (result & (1 << (size.bits() - 1))) != 0;
                let z = result == 0;
                let c = if shift_count > 0 {
                    (dst_val >> (shift_count - 1)) & 1 != 0
                } else {
                    false
                };
                self.set_flags(n, z, false, c, c);
                cycles = match size {
                    Size::Byte | Size::Word => 6,
                    Size::Long => 8,
                } + 2 * shift_count as u32;
            }
        }
        return cycles;
    }

    pub fn step(&mut self) -> u32 {
        if self.halted && self.pending_interrupts.is_empty() {
            return 0;
        }
        if let Some(&(level, vector)) = self.pending_interrupts.first() {
            let current_ipl = (self.sr >> 8) & 0x7;
            if u16::from(level) > current_ipl || (level == 7 && self.interrupt_nest_level < 7) {
                let cycles = self.process_interrupt(level, vector);
                self.cycle_count += cycles as u64;
                return cycles;
            }
        }
        let instr = self.decode();
        let cycles = self.execute(instr);
        self.cycle_count += cycles as u64;
        self.interrupt_ack = None;
        cycles
    }
/*
    pub fn load_program(&mut self, address: u32, program: &[u8]) {
        if address < 0x400000 {
            self.memory.load_rom_data(address, program).expect("Failed to load program into ROM");
        } else {
            for (i, &byte) in program.iter().enumerate() {
                self.cpu_write_byte(address + i as u32, byte);
            }
        }
        self.pc = address;
        self.prefetch();
    }
*/
}

```

`\\?\C:\Users\parobek\GitHub\rustyG3N\src\main.rs`:

```rs
// src/main.rs
mod memory;
mod m68k_cpu;
mod z80_cpu;

/*
use crate::memory::GenesisMemory;
use crate::m68k_cpu::{CPU as M68K, M68kMemory};
use crate::z80_cpu::{Z80, Z80Memory};
use crate::z80_cpu::DummyIoDevice;
 */
use crate::memory::{GenesisMemory, Z80Bus, DummyIoDevice};
use crate::m68k_cpu::{CPU as M68K, Exception};
use crate::m68k_cpu::M68kMemory;
use crate::z80_cpu::{Z80, IoDevice};

use std::env;

fn main() {
    // 1. Parse command-line to get ROM path, or default
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: cargo run -- <path_to_genesis_rom>");
        return;
    }
    let rom_path = &args[1];

    // 2. Create our memory and load the ROM
    let mut mem = GenesisMemory::new();
    if let Err(e) = mem.load_cartridge(rom_path) {
        eprintln!("Failed to load ROM: {}", e);
        return;
    }
    let rom_size = mem.rom.len();
    println!("Loaded ROM: {} ({} bytes)", rom_path, rom_size);

    // 3. Initialize the 68000 CPU
    // The Genesis reset vector is at offset 0 in the ROM for initial SP, offset 4 for initial PC.
    // However, many ROMs map the vector table at 0x000000, so let's read it from memory:
    let init_sp = mem.read_long(0x000000).unwrap_or(0x00FF0000);
    let init_pc = mem.read_long(0x000004).unwrap_or(0x00000100);

    let mut m68k_cpu = M68K::new(mem);

    // Set up the CPU registers from the reset vector
    m68k_cpu.a[7] = init_sp; // A7 is the 68k's stack pointer
    m68k_cpu.pc   = init_pc;

    // Prefetch (optional, but your CPU implementation might require it)
    m68k_cpu.prefetch();

    // 4. Create the Z80, hooking it to our memory
 
    /*
        // We pass a *mutable reference* to the same memory structure if we want
        // the Z80 to see the same state. Or you can store separate references if
        // your architecture differs. We'll do a trick with interior mutability:
        //   - We'll temporarily clone the memory to pass to Z80 for demonstration
        //   - Or we can unify them in a single structure with `RefCell` or `Arc<Mutex<...>>`.
        //   - Or we can use a global memory bus, etc.
        //
        // For demonstration, let's do a separate struct referencing the same data.
        //
        // let mut shared_mem = unsafe {
        //     // VERY rough approach: we move the memory out from M68K, then reconstruct later.
        //     // A more typical approach is to store the memory in a global or higher-level struct.
        //     // We'll just demonstrate the concept. In a real program, you'd design your memory bus
        //     // carefully so both CPUs can see it simultaneously.
        //     std::mem::transmute::<&mut crate::m68k_cpu::CPU<GenesisMemory>, &mut GenesisMemory>(&mut m68k_cpu.memory)
        // };
        //
        // let mut z80_bus = memory::Z80Bus::new(shared_mem);
    */
    
    let mut z80_bus = Z80Bus { 
        z80_ram: [0; 0x2000], // 8KB for demonstration
    };

    let mut z80_cpu = Z80::new();

    // A dummy I/O device for the Z80
    let mut dummy_io = DummyIoDevice;

    // Typically, you’d reset the Z80's PC, SP, etc. however the Genesis BIOS would do so.
    // The Z80 is initially held in reset on the real hardware until the 68k writes to certain regs.
    // For demonstration:
    z80_cpu.set_sp(0x0100);
    // PC is default 0x0000, or set as you like
    // z80_cpu.registers.pc = 0;

    // 5. Enter a main loop stepping both CPUs
    //   - Real Genesis code must synchronize them by cycles (the 68k runs ~7.6MHz, Z80 runs ~3.58MHz).
    //   - You’d also handle VBlank interrupts, line interrupts, bus arbitration, etc.
    //   - For now, we just run them in a simple loop.
    println!("Starting Emulation Loop (... incomplete). Press Ctrl+C to stop.");

    let mut total_instructions = 0u64;

    loop {
        // Step the 68000 by (for example) 200 cycles
        let mut cycles_used = 0;
        while cycles_used < 200 {
            let cycles = m68k_cpu.step();
            cycles_used += cycles;
            total_instructions += 1;
            // In a real emulator, you’d check for interrupts, do VDP checks, etc.
        }

        // Step the Z80 for some fraction of that (Z80 frequency is ~47% of 68k)
        let mut z80_cycles_used = 0;
        while z80_cycles_used < (200 * 47 / 100) {
            // Step 1 instruction
            let cyc = z80_cpu.step(&mut z80_bus, &mut dummy_io);
            z80_cycles_used += cyc as i32;
        }

        // For demonstration, break after some iteration:
        if total_instructions > 2_000_000 {
            println!("Stopping after 2,000,000 68k instructions (demo).");
            break;
        }

        // You might also insert a small sleep or check for user input, etc.
    }

    println!("Emulation Ended - Success!");
    println!("--------------------------");
    println!("Final 68k SP: 0x{:08X}", m68k_cpu.a[7]);
    println!("Final 68k PC: 0x{:08X}", m68k_cpu.pc);
    println!("Total 68k Instruct: {}", total_instructions);
    println!("Final Z80 SP: 0x{:04X}", z80_cpu.get_sp());
    println!("Final Z80 PC: 0x{:04X}", z80_cpu.get_pc());
    // println!("Total Z80 Instruct: {}", z80_cycles_used);
}

```

`\\?\C:\Users\parobek\GitHub\rustyG3N\src\memory.rs`:

```rs
// src/memory.rs

use std::io::Read;
use std::fs::File;
use std::path::Path;
use crate::m68k_cpu::{M68kMemory, Exception};
use crate::z80_cpu::{Z80Memory, IoDevice};

/// A very rough, incomplete memory map for the Sega Genesis 68k side.
/// For real emulation, you’d need to handle many more regions:
/// - 0x000000 - 0x3FFFFF: Cartridge ROM (max 4MB)
/// - 0xA00000 - 0xA0FFFF: Z80 access (sound CPU comms)
/// - 0xC00000 - 0xC0001F: VDP regs
/// - 0xE00000 - 0xE0FFFF: RAM (64KB)
/// - etc.
pub struct GenesisMemory {
    pub rom: Vec<u8>,
    pub ram_68k: [u8; 0x10000], // 64KB 68k RAM at 0xE00000
    pub z80_ram: [u8; 0x2000],  // 8KB Z80 RAM, banked or mirrored

    // Possibly other devices like VDP, IO, etc.
}   /// Trait that the 68000 CPU expects

impl GenesisMemory {
    pub fn new() -> Self {
        Self {
            rom: vec![],
            ram_68k: [0; 0x10000],
            z80_ram: [0; 0x2000],
        }
    }

    /// Load a .bin or .md Sega Genesis ROM from disk into `self.rom`.
    pub fn load_cartridge<P: AsRef<Path>>(&mut self, path: P) -> std::io::Result<()> {
        let mut file = File::open(path)?;
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)?;
        self.rom = buffer;
        Ok(())
    }

    // Helper: sign-extend 24-bit addresses to 32-bit
    fn mask_address_68k(&self, address: u32) -> u32 {
        address & 0xFFFFFF
    }

    /// Return a mirrored or clamped region if the cart is smaller than 4MB, etc.
    fn read_rom(&self, address: u32) -> u8 {
        if address as usize >= self.rom.len() {
            0 // open bus or mirror
        } else {
            self.rom[address as usize]
        }
    }
}

impl M68kMemory for GenesisMemory {
    fn read_byte(&mut self, address: u32) -> Result<u8, Exception> {
        let addr = self.mask_address_68k(address);

        match addr {
            0x000000..=0x3FFFFF => {
                // Cartridge ROM
                Ok(self.read_rom(addr))
            }
            0xE00000..=0xE0FFFF => {
                // 68k RAM
                let offset = (addr - 0xE00000) as usize;
                Ok(self.ram_68k[offset])
            }
            0xA00000..=0xA0FFFF => {
                // Z80 bus window (very simplified approach!)
                // Typically you'd handle bank / bus capture logic
                let offset = (addr & 0x1FFF) as usize;
                Ok(self.z80_ram[offset])
            }
            _ => {
                // For everything else, we just return 0 or raise AddressError.
                // The real Genesis has many more mapped addresses.
                Err(Exception::AddressError)
            }
        }
    }

    fn read_word(&mut self, address: u32) -> Result<u16, Exception> {
        // The 68k requires aligned word reads on even addresses.
        if address & 1 != 0 {
            return Err(Exception::AddressError);
        }

        let high = self.read_byte(address)? as u16;
        let low  = self.read_byte(address + 1)? as u16;
        Ok((high << 8) | low)
    }

    fn read_long(&mut self, address: u32) -> Result<u32, Exception> {
        // Must be aligned on a 2-byte boundary (strictly, 4 bytes for good measure).
        if address & 1 != 0 {
            return Err(Exception::AddressError);
        }

        let w1 = self.read_word(address)? as u32;
        let w2 = self.read_word(address + 2)? as u32;
        Ok((w1 << 16) | w2)
    }

    fn write_byte(&mut self, address: u32, value: u8) -> Result<(), Exception> {
        let addr = self.mask_address_68k(address);

        match addr {
            0x000000..=0x3FFFFF => {
                // Cartridge ROM is read-only; ignore or raise an error
                Ok(())
            }
            0xE00000..=0xE0FFFF => {
                // 68k RAM
                let offset = (addr - 0xE00000) as usize;
                self.ram_68k[offset] = value;
                Ok(())
            }
            0xA00000..=0xA0FFFF => {
                // Write to Z80 space
                let offset = (addr & 0x1FFF) as usize;
                self.z80_ram[offset] = value;
                Ok(())
            }
            _ => {
                Err(Exception::AddressError)
            }
        }
    }

    fn write_word(&mut self, address: u32, value: u16) -> Result<(), Exception> {
        if address & 1 != 0 {
            return Err(Exception::AddressError);
        }

        let high = (value >> 8) as u8;
        let low  = (value & 0xFF) as u8;
        self.write_byte(address,     high)?;
        self.write_byte(address + 1, low)?;
        Ok(())
    }

    fn write_long(&mut self, address: u32, value: u32) -> Result<(), Exception> {
        if address & 1 != 0 {
            return Err(Exception::AddressError);
        }

        let w1 = (value >> 16) as u16;
        let w2 = (value & 0xFFFF) as u16;
        self.write_word(address,     w1)?;
        self.write_word(address + 2, w2)?;
        Ok(())
    }
}

/// Simple trait for the Z80 memory. This is an example that matches the
/// `Memory` trait used by your Z80 CPU. Typically, your Z80 core expects:
///   fn read(&self, address: u16) -> u8
///   fn write(&mut self, address: u16, value: u8)
///
/// We'll implement a separate struct for clarity.
/// Example Z80 bus struct.
/// You can adjust fields to match your actual design.
pub struct Z80Bus {
    pub z80_ram: [u8; 0x2000], // 8KB for demonstration
}
/// A reference back to the shared GenesisMemory, so we can read/write
/// the same Z80 RAM or the 68k->Z80 window. In the real Genesis, the
/// Z80 sees 64KB of its own space, possibly including the YM2612 regs,
/// PSG, etc.
impl Z80Memory for Z80Bus {
// Implement the trait your Z80 CPU uses:
    fn read(&self, address: u16) -> u8 {
        // The Z80 has a 64KB address space, but the Genesis only exposes 8KB.
        // We'll mirror the RAM across the whole space for simplicity.
        let offset = (address as usize) & 0x1FFF;
        self.z80_ram[offset]
    }

    fn write(&mut self, address: u16, value: u8) {
        let offset = (address as usize) & 0x1FFF;
        self.z80_ram[offset] = value;
    }
}

/// A simple IO device that does nothing but satisfy the IoDevice trait.
pub struct DummyIoDevice;

impl IoDevice for DummyIoDevice {
    fn read(&self, _port: u16) -> u8 {
        0
    }

    fn write(&mut self, _port: u16, _value: u8) {
        // No-op
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyG3N\src\vdp.rs`:

```rs
use crate::memory::Memory;

// NTSC Genesis timing constants
const SCANLINES_PER_FRAME: u32 = 262;   // 224 visible + 38 VBlank
const CYCLES_PER_SCANLINE: u32 = 171;   // Base cycles per scanline (adjusted)
const VBLANK_START: u32 = 224;

pub struct Vdp {
    vram: [u8; 0x10000],     // 64 KB of Video RAM
    cram: [u16; 64],         // Color RAM for 64 palette entries (9-bit colors)
    vsram: [u8; 80],         // Vertical Scroll RAM
    registers: [u8; 24],     // VDP registers
    screen_buffer: Vec<u32>, // Pixel buffer in ARGB format
    width: usize,            // Screen width (e.g., 320 for H40 mode)
    height: usize,           // Screen height (e.g., 224)
    addr: u32,               // VDP address register
    code: u8,                // VDP code register (access mode)
    autoincrement: u8,       // Address autoincrement value
    plane_width: u32,        // Plane width in tiles
    plane_height: u32,       // Plane height in tiles
    current_scanline: u32,   // Current scanline for mid-scanline changes
    cycles: u32,             // Total cycles in the current frame (tracked externally)
    hblank_flag: bool,       // HBlank interrupt pending
    vblank_flag: bool,       // VBlank interrupt pending
    dma_active: bool,        // DMA active flag
}

impl Vdp {
    pub fn new() -> Self {
        let width = 320; // H40 mode for Sonic
        let height = 224; // NTSC visible lines
        Vdp {
            vram: [0; 0x10000],
            cram: [0; 64],
            vsram: [0; 80],
            registers: [0; 24],
            screen_buffer: vec![0; width * height],
            width,
            height,
            addr: 0,
            code: 0,
            autoincrement: 2,
            plane_width: 64,
            plane_height: 32,
            current_scanline: 0,
            cycles: 0,
            hblank_flag: false,
            vblank_flag: false,
            dma_active: false,
        }
    }

    /// Render a single scanline with cycle accuracy
    pub fn render_scanline(&mut self, scanline: usize) -> u32 {
        self.current_scanline = scanline as u32;
        let mut scanline_cycles = CYCLES_PER_SCANLINE;

        if scanline < self.height {
            let h40_mode = (self.registers[0x0C] & 0x81) != 0;
            self.width = if h40_mode { 320 } else { 256 };
            (self.plane_width, self.plane_height) = self.get_plane_size();

            let plane_b_base = ((self.registers[3] & 0x07) as u32) << 13;
            let plane_a_base = ((self.registers[2] & 0x38) as u32) << 10;
            let window_base = ((self.registers[4] & 0x07) as u32) << 13;
            let sprite_base = ((self.registers[5] & 0x7E) as u32) << 9;
            let hscroll_base = ((self.registers[0x0D] & 0x3F) as u32) << 10;

            self.render_plane_scanline(scanline, plane_b_base, hscroll_base, false);
            self.render_sprites_scanline(scanline, sprite_base, false);
            if self.is_window_enabled(scanline) {
                self.render_window_scanline(scanline, window_base);
            } else {
                self.render_plane_scanline(scanline, plane_a_base, hscroll_base, true);
            }
            self.render_sprites_scanline(scanline, sprite_base, true);

            self.hblank_flag = true; // Set HBlank after visible scanline
            scanline_cycles += 488; // Additional HBlank cycles
        } else if scanline == VBLANK_START as usize {
            self.vblank_flag = true; // Set VBlank at start of VBlank
            self.dma_active = true;  // DMA starts
        }

        if self.dma_active && scanline >= VBLANK_START as usize {
            scanline_cycles += 512; // DMA burst cycles for Sonic
            if scanline + 1 == SCANLINES_PER_FRAME as usize {
                self.dma_active = false; // DMA ends at frame end
            }
        }

        scanline_cycles
    }

    // Retained advanced feature methods
    fn get_plane_size(&self) -> (u32, u32) {
        let h_bits = self.registers[0x10] & 0x03;
        let v_bits = (self.registers[0x10] >> 4) & 0x03;
        let h_size = match h_bits {
            0 => 32,
            1 => 64,
            3 => 128,
            _ => 32,
        };
        let v_size = match v_bits {
            0 => 32,
            1 => 64,
            3 => 128,
            _ => 32,
        };
        (h_size, v_size)
    }

    fn is_window_enabled(&self, scanline: usize) -> bool {
        let h_pos_reg = self.registers[0x11];
        let v_pos_reg = self.registers[0x12];
        let h_pos = (h_pos_reg & 0x1F) as usize * 8;
        let v_pos = (v_pos_reg & 0x1F) as usize * 8;
        let right_aligned = (h_pos_reg & 0x80) != 0;

        if h_pos >= self.width || v_pos >= self.height {
            return false;
        }
        let above_window = scanline < v_pos;
        !above_window && (h_pos > 0 || v_pos > 0)
    }

    fn render_plane_scanline(&mut self, scanline: usize, tilemap_base: u32, hscroll_base: u32, is_plane_a: bool) {
        let vscroll_idx = if is_plane_a { 0 } else { 2 };
        let vscroll = u16::from_le_bytes([self.vsram[vscroll_idx], self.vsram[vscroll_idx + 1]]) as u32;
        let hscroll = u16::from_le_bytes([
            self.vram[(hscroll_base + (scanline as u32 * 4)) as usize],
            self.vram[(hscroll_base + (scanline as u32 * 4 + 1)) as usize],
        ]) as u32;

        let plane_y = (scanline as u32 + vscroll) % (self.plane_height * 8);
        let tile_row = plane_y / 8;
        let pixel_y_in_tile = plane_y % 8;

        for screen_x in 0..self.width {
            let plane_x = (screen_x as u32 + hscroll) % (self.plane_width * 8);
            let tile_col = plane_x / 8;
            let pixel_x_in_tile = plane_x % 8;

            let tilemap_addr = tilemap_base + (tile_row * self.plane_width * 2 + tile_col * 2) as u32;
            let entry = self.read_vram_u16(tilemap_addr);

            let pattern_index = entry & 0x7FF;
            let palette = (entry >> 13) & 0x3;
            let hflip = (entry & 0x0800) != 0;
            let vflip = (entry & 0x1000) != 0;
            let priority = (entry & 0x8000) != 0;

            let tile_x = if hflip { 7 - pixel_x_in_tile } else { pixel_x_in_tile };
            let tile_y = if vflip { 7 - pixel_y_in_tile } else { pixel_y_in_tile };

            let color = self.get_pixel_color(pattern_index, tile_x, tile_y, palette);
            if color != 0 {
                let idx = scanline * self.width + screen_x;
                if priority || self.screen_buffer[idx] == 0 {
                    self.screen_buffer[idx] = self.convert_color(self.cram[color as usize]);
                }
            }
        }
    }

    fn render_sprites_scanline(&mut self, scanline: usize, sprite_base: u32, high_priority: bool) {
        let mut sprite_count = 0;
        let mut current = 0;
        let mut processed = [false; 80];
    
        while sprite_count < 20 && current < 80 && !processed[current as usize] {
            let sprite_addr = sprite_base + current * 8;
            processed[current as usize] = true;
    
            let y_pos = self.read_vram_u16(sprite_addr) & 0x3FF;
            let size = self.read_vram_u16(sprite_addr + 2);
            let v_size = ((size >> 2) & 0x3) + 1;
            let h_size = (size & 0x3) + 1;
            let link = (size >> 8) & 0x7F;
            let attrib = self.read_vram_u16(sprite_addr + 4);
            let pattern_index = attrib & 0x7FF;
            let palette = (attrib >> 13) & 0x3;  // Fixed from 'entry'
            let hflip = (attrib & 0x0800) != 0;  // Fixed from 'entry'
            let vflip = (attrib & 0x1000) != 0;  // Fixed from 'entry'
            let priority = (attrib & 0x8000) != 0;  // Fixed from 'entry'
            let x_pos = self.read_vram_u16(sprite_addr + 6) & 0x3FF;
    
            if priority == high_priority {
                let sprite_top = ((y_pos as i32) - 128);
                let sprite_bottom = sprite_top + ((v_size * 8) as i32);
                if sprite_top <= (scanline as i32) && (scanline as i32) < sprite_bottom {
                    let row_in_sprite = ((scanline as i32) - sprite_top);
                    self.render_sprite_row(
                        ((x_pos as i32) - 128),
                        row_in_sprite,
                        h_size,
                        v_size,
                        pattern_index,
                        palette,
                        hflip,
                        vflip,
                        priority,
                        scanline
                    );
                    sprite_count += 1;
                }
            }
            current = link;
            if current == 0 { break; }
        }
    }

    fn render_sprite_row(&mut self, x_pos: i32, row_in_sprite: i32, h_size: u16, v_size: u16, pattern_index: u16, palette: u16, hflip: bool, vflip: bool, priority: bool, scanline: usize) {
        let tile_y = if vflip {
            (v_size * 8 - 1 - row_in_sprite as u32)
        } else {
            row_in_sprite as u32
        };
        let tile_row = tile_y / 8;
        let pixel_y = tile_y % 8;

        for h in 0..h_size * 8 {
            let tile_x = if hflip { h_size * 8 - 1 - h } else { h };
            let tile_col = tile_x / 8;
            let pixel_x = tile_x % 8;

            let tile_index = pattern_index + tile_row * h_size + tile_col;
            let color = self.get_pixel_color(tile_index, pixel_x, pixel_y, palette);
            if color != 0 {
                let screen_x = x_pos + h as i32;
                if screen_x >= 0 && screen_x < self.width as i32 {
                    let idx = scanline * self.width + screen_x as usize;
                    if priority || self.screen_buffer[idx] == 0 {
                        self.screen_buffer[idx] = self.convert_color(self.cram[color as usize]);
                    }
                }
            }
        }
    }

    fn render_window_scanline(&mut self, scanline: usize, tilemap_base: u32) {
        let v_pos = (self.registers[0x12] & 0x1F) as usize * 8;
        let h_pos = (self.registers[0x11] & 0x1F) as usize * 8;
        let right_aligned = (self.registers[0x11] & 0x80) != 0;

        let window_y = (scanline - v_pos) as u32;
        if window_y >= self.plane_height * 8 { return; }
        let tile_row = window_y / 8;
        let pixel_y_in_tile = window_y % 8;

        for screen_x in 0..self.width {
            let in_window_h = if right_aligned { screen_x >= h_pos } else { screen_x < h_pos };
            if !in_window_h { continue; }

            let window_x = screen_x as u32 - if right_aligned { h_pos as u32 } else { 0 };
            let tile_col = window_x / 8;
            let pixel_x_in_tile = window_x % 8;

            let tilemap_addr = tilemap_base + (tile_row * self.plane_width * 2 + tile_col * 2) as u32;
            let entry = self.read_vram_u16(tilemap_addr);

            let pattern_index = entry & 0x7FF;
            let palette = (entry >> 13) & 0x3;
            let hflip = (entry & 0x0800) != 0;
            let vflip = (entry & 0x1000) != 0;
            let priority = (entry & 0x8000) != 0;

            let tile_x = if hflip { 7 - pixel_x_in_tile } else { pixel_x_in_tile };
            let tile_y = if vflip { 7 - pixel_y_in_tile } else { pixel_y_in_tile };

            let color = self.get_pixel_color(pattern_index, tile_x, tile_y, palette);
            if color != 0 {
                let idx = scanline * self.width + screen_x;
                if priority || self.screen_buffer[idx] == 0 {
                    self.screen_buffer[idx] = self.convert_color(self.cram[color as usize]);
                }
            }
        }
    }

    fn get_pixel_color(&self, pattern_index: u16, tile_x: u32, tile_y: u32, palette: u16) -> u16 {
        let pattern_addr = (pattern_index as u32 * 32 + tile_y * 4) as u32;
        let byte_index = (tile_x / 2) as u32;
        let nibble = if tile_x % 2 == 0 {
            self.vram[(pattern_addr + byte_index) as usize] >> 4
        } else {
            self.vram[(pattern_addr + byte_index) as usize] & 0xF
        };
        if nibble == 0 { 0 } else { palette * 16 + nibble as u16 }
    }

    fn convert_color(&self, color: u16) -> u32 {
        let b = ((color & 0x000E) >> 1) as u8;
        let g = ((color & 0x00E0) >> 5) as u8;
        let r = ((color & 0x0E00) >> 9) as u8;
        let r_8 = ((r as u32 * 255) / 7) as u8;
        let g_8 = ((g as u32 * 255) / 7) as u8;
        let b_8 = ((b as u32 * 255) / 7) as u8;
        0xFF000000 | ((r_8 as u32) << 16) | ((g_8 as u32) << 8) | b_8 as u32
    }

    fn read_vram_u16(&self, addr: u32) -> u16 {
        if addr + 1 < 0x10000 {
            (self.vram[addr as usize] as u16) | ((self.vram[(addr + 1) as usize] as u16) << 8)
        } else {
            0
        }
    }

    pub fn get_screen_buffer(&self) -> &[u32] {
        &self.screen_buffer
    }

    pub fn write_control(&mut self, value: u32) {
        if (value & 0xC000) == 0x8000 {
            let reg = (value >> 8) & 0x1F;
            let data = value & 0xFF;
            if reg < 24 {
                self.registers[reg as usize] = data as u8;
            }
        } else {
            self.code = ((value >> 14) & 0x3) as u8;
            self.addr = value & 0x3FFF;
        }
    }

    pub fn write_data(&mut self, value: u16) {
        match self.code {
            0 => {
                if (self.addr + 1) < 0x10000 {
                    self.vram[self.addr as usize] = (value & 0xFF) as u8;
                    self.vram[(self.addr + 1) as usize] = (value >> 8) as u8;
                }
            }
            1 => {
                if self.addr < 128 {
                    self.cram[(self.addr / 2) as usize] = value & 0x0EEE;
                }
            }
            2 => {
                if self.addr < 80 {
                    self.vsram[self.addr as usize] = (value & 0xFF) as u8;
                    self.vsram[(self.addr + 1) as usize] = (value >> 8) as u8;
                }
            }
            _ => {}
        }
        self.addr = (self.addr + self.autoincrement as u32) & 0xFFFF;
    }

    pub fn read_data(&self) -> u16 {
        match self.code {
            0 => self.read_vram_u16(self.addr),
            1 => if self.addr < 128 { self.cram[(self.addr / 2) as usize] } else { 0 },
            2 => if self.addr < 80 { u16::from_le_bytes([self.vsram[self.addr as usize], self.vsram[(self.addr + 1) as usize]]) } else { 0 },
            _ => 0,
        }
    }

    pub fn check_hblank_interrupt(&self) -> bool {
        self.hblank_flag && (self.registers[0] & 0x10) != 0
    }

    pub fn check_vblank_interrupt(&self) -> bool {
        self.vblank_flag && (self.registers[1] & 0x20) != 0
    }

    pub fn reset_interrupt_flags(&mut self) {
        self.hblank_flag = false;
        self.vblank_flag = false;
    }

    pub fn is_dma_active(&self) -> bool {
        self.dma_active
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyG3N\src\z80_cpu.rs`:

```rs
// z80_cpu.rs

//!
//! Zilog Z80 CPU Core Implementation in Rust
//!
//! This module provides an emulation of the Zilog Z80 microprocessor, a widely used 8-bit CPU
//! introduced in 1976. The Z80 features a 16-bit address bus (64KB address space), an 8-bit data
//! bus, and a rich instruction set with 158 opcodes, including undocumented ones. This
//! implementation includes the CPU's registers, instruction execution, interrupt handling, and
//! I/O operations, aiming for compatibility with the official Z80 specifications.
//!
//! Key Features:
//! - Full register set: main (A, F, B, C, D, E, H, L), alternate, index (IX, IY), SP, PC, I, R
//! - Flag register (F) with S, Z, H, P/V, N, C flags
//! - Support for standard opcodes, CB/DD/ED/FD prefixes
//! - Interrupt modes (IM 0, IM 1, IM 2) and NMI handling
//! - Cycle-accurate execution for implemented instructions
//!
//! Dependencies:
//! - `memory.rs`: Provides the `Memory` trait for memory access
//!
//! Usage:
//! Create a `Z80` instance with `Z80::new()`, then use `step()` to execute instructions,
//! interfacing with memory and I/O devices via traits.
//!
//! Limitations:
//! - Some opcodes (e.g., IN, OUT) are unimplemented; they panic with `unimplemented!()`.
//! - Undocumented opcodes and edge cases may not be fully supported yet.
//!

// use crate::memory::Memory;

pub trait Z80Memory {
    fn read(&self, address: u16) -> u8;
    fn write(&mut self, address: u16, value: u8);
}

// Constants for flag bits in the F register
pub const FLAG_C: u8 = 0b00000001;  // Carry flag (bit 0)
pub const FLAG_N: u8 = 0b00000010;  // Add/Subtract flag (bit 1)
pub const FLAG_PV: u8 = 0b00000100; // Parity/Overflow flag (bit 2)
pub const FLAG_H: u8 = 0b00010000;  // Half-carry flag (bit 4)
pub const FLAG_Z: u8 = 0b01000000;  // Zero flag (bit 6)
pub const FLAG_S: u8 = 0b10000000;  // Sign flag (bit 7)

/// Represents the complete register set of the Z80 CPU.
pub struct Registers {
    pub a: u8,      // Accumulator
    pub f: u8,      // Flag register
    pub b: u8,      // B register
    pub c: u8,      // C register
    pub d: u8,      // D register
    pub e: u8,      // E register
    pub h: u8,      // H register (high byte of HL)
    pub l: u8,      // L register (low byte of HL)
    pub a_alt: u8,  // Alternate accumulator
    pub f_alt: u8,  // Alternate flag register
    pub b_alt: u8,  // Alternate B register
    pub c_alt: u8,  // Alternate C register
    pub d_alt: u8,  // Alternate D register
    pub e_alt: u8,  // Alternate E register
    pub h_alt: u8,  // Alternate H register
    pub l_alt: u8,  // Alternate L register
    pub ix: u16,    // Index register IX
    pub iy: u16,    // Index register IY
    pub sp: u16,    // Stack pointer
    pub pc: u16,    // Program counter
    pub i: u8,      // Interrupt vector register
    pub r: u8,      // Memory refresh register
}

impl Registers {
    /// Creates a new `Registers` instance with all values initialized to zero.
    pub fn new() -> Self {
        Registers {
            a: 0, f: 0, b: 0, c: 0, d: 0, e: 0, h: 0, l: 0,
            a_alt: 0, f_alt: 0, b_alt: 0, c_alt: 0, d_alt: 0, e_alt: 0, h_alt: 0, l_alt: 0,
            ix: 0, iy: 0, sp: 0, pc: 0, i: 0, r: 0,
        }
    }

    /// Gets the 16-bit BC register pair.
    pub fn get_bc(&self) -> u16 { ((self.b as u16) << 8) | self.c as u16 }

    /// Sets the 16-bit BC register pair.
    pub fn set_bc(&mut self, value: u16) { self.b = (value >> 8) as u8; self.c = value as u8; }

    /// Gets the 16-bit DE register pair.
    pub fn get_de(&self) -> u16 { ((self.d as u16) << 8) | self.e as u16 }

    /// Sets the 16-bit DE register pair.
    pub fn set_de(&mut self, value: u16) { self.d = (value >> 8) as u8; self.e = value as u8; }

    /// Gets the 16-bit HL register pair.
    pub fn get_hl(&self) -> u16 { ((self.h as u16) << 8) | self.l as u16 }

    /// Sets the 16-bit HL register pair.
    pub fn set_hl(&mut self, value: u16) { self.h = (value >> 8) as u8; self.l = value as u8; }

    /// Gets the 16-bit AF register pair.
    pub fn get_af(&self) -> u16 { ((self.a as u16) << 8) | self.f as u16 }

    /// Sets the 16-bit AF register pair.
    pub fn set_af(&mut self, value: u16) { self.a = (value >> 8) as u8; self.f = value as u8; }

    /// Sets a flag in the F register.
    pub fn set_flag(&mut self, flag: u8, value: bool) {
        if value { self.f |= flag; } else { self.f &= !flag; }
    }

    /// Gets the state of a flag in the F register.
    pub fn get_flag(&self, flag: u8) -> bool { self.f & flag != 0 }
}

/// Trait defining the interface for I/O devices in the Z80 emulator.
pub trait IoDevice {
    /// Reads a byte from the specified 16-bit port.
    fn read(&self, port: u16) -> u8;

    /// Writes a byte to the specified 16-bit port.
    fn write(&mut self, port: u16, value: u8);
}

/// A dummy I/O device that returns 0 on reads and ignores writes.
pub struct DummyIoDevice;

impl IoDevice for DummyIoDevice {
    fn read(&self, _port: u16) -> u8 { 0 }
    fn write(&mut self, _port: u16, _value: u8) {}
}

/// Represents the Z80 CPU, encapsulating its state and execution logic.
pub struct Z80 {
    registers: Registers, // CPU registers
    halted: bool,        // Halt state
    iff1: bool,          // Interrupt Flip-Flop 1 (enabled/disabled)
    iff2: bool,          // Interrupt Flip-Flop 2 (for NMI)
    im: u8,              // Interrupt mode (0, 1, or 2)
    cycles: u64,         // Total cycles elapsed
}

impl Z80 {
    /// Creates a new `Z80` instance with default values.
    pub fn new() -> Self {
        Z80 {
            registers: Registers::new(),
            halted: false,
            iff1: false,
            iff2: false,
            im: 0,
            cycles: 0,
        }
    }

    /// Executes one CPU instruction, returning the number of cycles consumed.
    pub fn step(&mut self, memory: &mut dyn Z80Memory, io: &mut dyn IoDevice) -> u8 {
        if self.halted {
            self.registers.r = self.registers.r.wrapping_add(1);
            return 4; // HALT takes 4 cycles
        }
        let opcode = self.fetch_byte(memory);
        let cycles = self.execute(opcode, memory, io);
        self.cycles += cycles as u64;
        cycles
    }

    /// Fetches a byte from memory at PC, incrementing PC and R.
    pub fn fetch_byte(&mut self, memory: &dyn Z80Memory) -> u8 {
        let byte = memory.read(self.registers.pc);
        self.registers.pc = self.registers.pc.wrapping_add(1);
        self.registers.r = self.registers.r.wrapping_add(1);
        byte
    }

    /// Fetches a 16-bit word from memory, incrementing PC twice.
    pub fn fetch_word(&mut self, memory: &dyn Z80Memory) -> u16 {
        let low = self.fetch_byte(memory) as u16;
        let high = self.fetch_byte(memory) as u16;
        (high << 8) | low
    }

    /// Gets a register value by index (0-7: B, C, D, E, H, L, (HL), A).
    pub fn get_register(&self, r: u8, memory: &dyn Z80Memory) -> u8 {
        match r {
            0 => self.registers.b,
            1 => self.registers.c,
            2 => self.registers.d,
            3 => self.registers.e,
            4 => self.registers.h,
            5 => self.registers.l,
            6 => memory.read(self.registers.get_hl()),
            7 => self.registers.a,
            _ => unreachable!("Invalid register index"),
        }
    }

    /// Sets a register value by index (0-7: B, C, D, E, H, L, (HL), A).
    pub fn set_register(&mut self, r: u8, value: u8, memory: &mut dyn Z80Memory) {
        match r {
            0 => self.registers.b = value,
            1 => self.registers.c = value,
            2 => self.registers.d = value,
            3 => self.registers.e = value,
            4 => self.registers.h = value,
            5 => self.registers.l = value,
            6 => memory.write(self.registers.get_hl(), value),
            7 => self.registers.a = value,
            _ => unreachable!("Invalid register index"),
        }
    }

    /// Pushes the PC onto the stack.
    pub fn push_pc(&mut self, memory: &mut dyn Z80Memory) {
        self.registers.sp = self.registers.sp.wrapping_sub(2);
        memory.write(self.registers.sp, self.registers.pc as u8);
        memory.write(self.registers.sp + 1, (self.registers.pc >> 8) as u8);
    }

    /// Pops the PC from the stack.
    pub fn pop_pc(&mut self, memory: &dyn Z80Memory) {
        let low = memory.read(self.registers.sp) as u16;
        let high = memory.read(self.registers.sp + 1) as u16;
        self.registers.pc = (high << 8) | low;
        self.registers.sp = self.registers.sp.wrapping_add(2);
    }

    /// Executes the given opcode, returning the number of cycles.
    pub fn execute(&mut self, opcode: u8, memory: &mut dyn Z80Memory, io: &mut dyn IoDevice) -> u8 {
        match opcode {
            // No Operation: Does nothing, takes 4 cycles
            0x00 => 4, // NOP

            // Load BC with immediate 16-bit value nn from memory (PC+1, PC+2)
            0x01 => { let nn = self.fetch_word(memory); self.registers.set_bc(nn); 10 }, // LD BC, nn

            // Store accumulator A to memory location pointed to by BC
            0x02 => { memory.write(self.registers.get_bc(), self.registers.a); 7 }, // LD (BC), A

            // Increment register B, setting S, Z, H, PV flags (N reset, C unaffected)
            0x04 => { self.registers.b = self.inc_8bit(self.registers.b); 4 }, // INC B

            // Decrement register B, setting S, Z, H, PV flags (N set, C unaffected)
            0x05 => { self.registers.b = self.dec_8bit(self.registers.b); 4 }, // DEC B

            // Load register B with immediate 8-bit value n from memory (PC+1)
            0x06 => {
                let n = self.fetch_byte(memory); // Fetch the immediate value
                self.registers.b = n;            // Load it into register B
                7                                // Return the number of cycles
            }, // LD B, n

            // Rotate Left Circular Accumulator: Bit 7 to bit 0 and C flag, H/N reset
            0x07 => {
                let a = self.registers.a;
                let carry = (a & 0x80) != 0;
                self.registers.a = (a << 1) | if carry { 1 } else { 0 };
                self.registers.set_flag(FLAG_H, false);
                self.registers.set_flag(FLAG_N, false);
                self.registers.set_flag(FLAG_C, carry);
                4
            }, // RLCA

            // Exchange AF with AF': Swap accumulator and flags with shadow registers
            0x08 => {
                let temp_a = self.registers.a;
                let temp_f = self.registers.f;
                self.registers.a = self.registers.a_alt;
                self.registers.f = self.registers.f_alt;
                self.registers.a_alt = temp_a;
                self.registers.f_alt = temp_f;
                4
            }, // EX AF, AF'

            // Add 16-bit register pair BC to HL, setting H and C flags (others unaffected)
            0x09 => {
                let hl = self.registers.get_hl();
                let bc = self.registers.get_bc();
                let (result, carry) = hl.overflowing_add(bc);
                let half_carry = ((hl & 0x0FFF) + (bc & 0x0FFF)) > 0x0FFF;
                self.registers.set_hl(result);
                self.registers.set_flag(FLAG_H, half_carry);
                self.registers.set_flag(FLAG_N, false);
                self.registers.set_flag(FLAG_C, carry);
                11
            }, // ADD HL, BC

            // Load accumulator A from memory location pointed to by BC
            0x0A => {
                let bc = self.registers.get_bc();
                self.registers.a = memory.read(bc);
                7
            }, // LD A, (BC)

            // Increment register C, setting S, Z, H, PV flags (N reset, C unaffected)
            0x0C => { self.registers.c = self.inc_8bit(self.registers.c); 4 }, // INC C

            // Decrement register C, setting S, Z, H, PV flags (N set, C unaffected)
            0x0D => { self.registers.c = self.dec_8bit(self.registers.c); 4 }, // DEC C

            // Load register C with immediate 8-bit value n from memory (PC+1)
            0x0E => { self.registers.c = self.fetch_byte(memory); 7 }, // LD C, n

            // Rotate Right Circular Accumulator: Bit 0 to bit 7 and C flag, H/N reset
            0x0F => {
                let a = self.registers.a;
                let carry = (a & 0x01) != 0;
                self.registers.a = (a >> 1) | if carry { 0x80 } else { 0 };
                self.registers.set_flag(FLAG_H, false);
                self.registers.set_flag(FLAG_N, false);
                self.registers.set_flag(FLAG_C, carry);
                4
            }, // RRCA

            // Decrement B and jump relative if B != 0 (e is signed offset from PC+2)
            0x10 => {
                self.registers.b = self.registers.b.wrapping_sub(1);
                let e = self.fetch_byte(memory) as i8;
                if self.registers.b != 0 {
                    self.registers.pc = self.registers.pc.wrapping_add(e as u16);
                    13
                } else {
                    8
                }
            }, // DJNZ e

            // Load DE with immediate 16-bit value nn from memory (PC+1, PC+2)
            0x11 => { let nn = self.fetch_word(memory); self.registers.set_de(nn); 10 }, // LD DE, nn

            // Store accumulator A to memory location pointed to by DE
            0x12 => { memory.write(self.registers.get_de(), self.registers.a); 7 }, // LD (DE), A

            // Increment register D, setting S, Z, H, PV flags (N reset, C unaffected)
            0x14 => { self.registers.d = self.inc_8bit(self.registers.d); 4 }, // INC D

            // Decrement register D, setting S, Z, H, PV flags (N set, C unaffected)
            0x15 => { self.registers.d = self.dec_8bit(self.registers.d); 4 }, // DEC D

            // Load register D with immediate 8-bit value n from memory (PC+1)
            0x16 => { let n = self.fetch_byte(memory); self.registers.d = n; 7 }, // LD D, n

            // Rotate Left Accumulator through Carry: Bit 7 to C, C to bit 0, H/N reset
            0x17 => {
                let a = self.registers.a;
                let old_carry = if self.registers.get_flag(FLAG_C) { 1 } else { 0 };
                let new_carry = (a & 0x80) != 0;
                self.registers.a = (a << 1) | old_carry;
                self.registers.set_flag(FLAG_H, false);
                self.registers.set_flag(FLAG_N, false);
                self.registers.set_flag(FLAG_C, new_carry);
                4
            }, // RLA

            // Jump relative: Add signed offset e to PC (PC+2 + e)
            0x18 => {
                let e = self.fetch_byte(memory) as i8;
                self.registers.pc = self.registers.pc.wrapping_add(e as u16);
                12
            }, // JR e

            // Load accumulator A from memory location pointed to by DE
            0x1A => {
                let de = self.registers.get_de();
                self.registers.a = memory.read(de);
                7
            }, // LD A, (DE)

            // Increment register E, setting S, Z, H, PV flags (N reset, C unaffected)
            0x1C => { self.registers.e = self.inc_8bit(self.registers.e); 4 }, // INC E

            // Decrement register E, setting S, Z, H, PV flags (N set, C unaffected)
            0x1D => { self.registers.e = self.dec_8bit(self.registers.e); 4 }, // DEC E

            // Load register E with immediate 8-bit value n from memory (PC+1)
            0x1E => { let n = self.fetch_byte(memory); self.registers.e = n; 7 }, // LD E, n

            // Rotate Right Accumulator through Carry: Bit 0 to C, C to bit 7, H/N reset
            0x1F => {
                let a = self.registers.a;
                let old_carry = if self.registers.get_flag(FLAG_C) { 0x80 } else { 0 };
                let new_carry = (a & 0x01) != 0;
                self.registers.a = (a >> 1) | old_carry;
                self.registers.set_flag(FLAG_H, false);
                self.registers.set_flag(FLAG_N, false);
                self.registers.set_flag(FLAG_C, new_carry);
                4
            }, // RRA

            // Jump relative if Zero flag is reset (NZ): PC+2 + e if Z = 0
            0x20 => {
                let e = self.fetch_byte(memory) as i8;
                if !self.registers.get_flag(FLAG_Z) {
                    self.registers.pc = self.registers.pc.wrapping_add(e as u16);
                    12
                } else {
                    7
                }
            }, // JR NZ, e

            // Load HL with immediate 16-bit value nn from memory (PC+1, PC+2)
            0x21 => { let nn = self.fetch_word(memory); self.registers.set_hl(nn); 10 }, // LD HL, nn

            // Store HL to memory at address nn (little-endian: L at nn, H at nn+1)
            0x22 => {
                let nn = self.fetch_word(memory);
                let hl = self.registers.get_hl();
                memory.write(nn, (hl & 0xFF) as u8);
                memory.write(nn.wrapping_add(1), (hl >> 8) as u8);
                16
            }, // LD (nn), HL

            // Increment register H, setting S, Z, H, PV flags (N reset, C unaffected)
            0x23 => {
                let hl = self.registers.get_hl();       // Get current HL value
                let new_hl = hl.wrapping_add(1);        // Increment with wrapping
                self.registers.set_hl(new_hl);          // Set new HL value
                6                                       // Return 6 cycles
            }, // INC HL

            // Increment register H, setting S, Z, H, PV flags (N reset, C unaffected)
            0x24 => { self.registers.h = self.inc_8bit(self.registers.h); 4 }, // INC H

            // Decrement register H, setting S, Z, H, PV flags (N set, C unaffected)
            0x25 => { self.registers.h = self.dec_8bit(self.registers.h); 4 }, // DEC H

            // Load register H with immediate 8-bit value n from memory (PC+1)
            0x26 => { let n = self.fetch_byte(memory); self.registers.h = n; 7 }, // LD H, n

            // Decimal Adjust Accumulator: Adjust A for BCD arithmetic after ADD/SUB
            0x27 => {
                let mut a = self.registers.a;
                let mut correction = 0;
                let carry = self.registers.get_flag(FLAG_C);
                let half_carry = self.registers.get_flag(FLAG_H);
                let subtract = self.registers.get_flag(FLAG_N);

                if half_carry || (!subtract && (a & 0x0F) > 9) {
                    correction |= 0x06;
                }
                if carry || (!subtract && a > 0x99) || (subtract && ((a & 0xF0) > 0x90)) {
                    correction |= 0x60;
                }
                if subtract {
                    a = a.wrapping_sub(correction);
                } else {
                    a = a.wrapping_add(correction);
                }
                let new_carry = carry || (correction & 0x60) != 0;
                self.registers.set_flag(FLAG_S, a & 0x80 != 0);
                self.registers.set_flag(FLAG_Z, a == 0);
                self.registers.set_flag(FLAG_H, false);
                self.registers.set_flag(FLAG_PV, Self::parity(a));
                self.registers.set_flag(FLAG_C, new_carry);
                self.registers.a = a;
                4
            }, // DAA

            // Jump relative if Zero flag is set (Z): PC+2 + e if Z = 1
            0x28 => {
                let e = self.fetch_byte(memory) as i8;
                if self.registers.get_flag(FLAG_Z) {
                    self.registers.pc = self.registers.pc.wrapping_add(e as u16);
                    12
                } else {
                    7
                }
            }, // JR Z, e

            // Add 16-bit register pair HL to HL (double HL), setting H and C flags
            0x29 => {
                let hl = self.registers.get_hl();
                let (result, carry) = hl.overflowing_add(hl);
                let half_carry = ((hl & 0x0FFF) + (hl & 0x0FFF)) > 0x0FFF;
                self.registers.set_hl(result);
                self.registers.set_flag(FLAG_H, half_carry);
                self.registers.set_flag(FLAG_N, false);
                self.registers.set_flag(FLAG_C, carry);
                11
            }, // ADD HL, HL

            // Load HL from memory at address nn (little-endian: L from nn, H from nn+1)
            0x2A => {
                let nn = self.fetch_word(memory);
                let low = memory.read(nn);
                let high = memory.read(nn.wrapping_add(1));
                self.registers.set_hl((high as u16) << 8 | low as u16);
                16
            }, // LD HL, (nn)

            // Increment register L, setting S, Z, H, PV flags (N reset, C unaffected)
            0x2C => { self.registers.l = self.inc_8bit(self.registers.l); 4 }, // INC L

            // Decrement register L, setting S, Z, H, PV flags (N set, C unaffected)
            0x2D => { self.registers.l = self.dec_8bit(self.registers.l); 4 }, // DEC L

            // Load register L with immediate 8-bit value n from memory (PC+1)
            0x2E => { let n = self.fetch_byte(memory); self.registers.l = n; 7 }, // LD L, n

            // Complement Accumulator: Invert all bits of A, set H and N flags
            0x2F => {
                self.registers.a = !self.registers.a;
                self.registers.set_flag(FLAG_H, true);
                self.registers.set_flag(FLAG_N, true);
                4
            }, // CPL

            // Jump relative if Carry flag is reset (NC): PC+2 + e if C = 0
            0x30 => {
                let e = self.fetch_byte(memory) as i8;
                if !self.registers.get_flag(FLAG_C) {
                    self.registers.pc = self.registers.pc.wrapping_add(e as u16);
                    12
                } else {
                    7
                }
            }, // JR NC, e

            // Load Stack Pointer with immediate 16-bit value nn from memory (PC+1, PC+2)
            0x31 => { self.registers.sp = self.fetch_word(memory); 10 }, // LD SP, nn

            // Store accumulator A to memory at address nn (PC+1, PC+2)
            0x32 => {
                let nn = self.fetch_word(memory);
                memory.write(nn, self.registers.a);
                13
            }, // LD (nn), A

            // Increment value at (HL), setting S, Z, H, PV flags (N reset, C unaffected)
            0x34 => {
                let hl = self.registers.get_hl();
                let value = memory.read(hl);
                let new_value = self.inc_8bit(value);
                memory.write(hl, new_value);
                11
            }, // INC (HL)

            // Decrement value at (HL), setting S, Z, H, PV flags (N set, C unaffected)
            0x35 => {
                let hl = self.registers.get_hl();
                let value = memory.read(hl);
                let new_value = self.dec_8bit(value);
                memory.write(hl, new_value);
                11
            }, // DEC (HL)

            // Load memory at (HL) with immediate 8-bit value n from memory (PC+1)
            0x36 => {
                let n = self.fetch_byte(memory);
                let hl = self.registers.get_hl();
                memory.write(hl, n);
                10
            }, // LD (HL), n

            // Set Carry Flag: C flag set, H and N flags reset
            0x37 => {
                self.registers.set_flag(FLAG_H, false);
                self.registers.set_flag(FLAG_N, false);
                self.registers.set_flag(FLAG_C, true);
                4
            }, // SCF

            // Jump relative if Carry flag is set (C): PC+2 + e if C = 1
            0x38 => {
                let e = self.fetch_byte(memory) as i8;
                if self.registers.get_flag(FLAG_C) {
                    self.registers.pc = self.registers.pc.wrapping_add(e as u16);
                    12
                } else {
                    7
                }
            }, // JR C, e

            // Add 16-bit register pair DE to HL, setting H and C flags
            0x39 => {
                let hl = self.registers.get_hl();
                let de = self.registers.get_de();
                let (result, carry) = hl.overflowing_add(de);
                let half_carry = ((hl & 0x0FFF) + (de & 0x0FFF)) > 0x0FFF;
                self.registers.set_hl(result);
                self.registers.set_flag(FLAG_H, half_carry);
                self.registers.set_flag(FLAG_N, false);
                self.registers.set_flag(FLAG_C, carry);
                11
            }, // ADD HL, DE

            // Load accumulator A from memory at address nn (PC+1, PC+2)
            0x3A => {
                let nn = self.fetch_word(memory);
                self.registers.a = memory.read(nn);
                13
            }, // LD A, (nn)

            // Increment register A, setting S, Z, H, PV flags (N reset, C unaffected)
            0x3C => { self.registers.a = self.inc_8bit(self.registers.a); 4 }, // INC A

            // Decrement register A, setting S, Z, H, PV flags (N set, C unaffected)
            0x3D => { self.registers.a = self.dec_8bit(self.registers.a); 4 }, // DEC A

            // Load register A with immediate 8-bit value n from memory (PC+1)
            0x3E => { self.registers.a = self.fetch_byte(memory); 7 }, // LD A, n

            // Complement Carry Flag: Invert C flag, set H to old C, N reset
            0x3F => {
                let carry = self.registers.get_flag(FLAG_C);
                self.registers.set_flag(FLAG_H, carry);
                self.registers.set_flag(FLAG_N, false);
                self.registers.set_flag(FLAG_C, !carry);
                4
            }, // CCF

            // Load register-to-register or memory at (HL): 0x40-0x7F except 0x76 (HALT)
            0x40..=0x7F => {
                if opcode == 0x76 {
                    self.halted = true;
                    4 // HALT: Halt CPU until interrupt
                } else {
                    let dest = (opcode >> 3) & 0x07; // Bits 3-5: destination register
                    let src = opcode & 0x07;          // Bits 0-2: source register
                    let value = self.get_register(src, memory);
                    self.set_register(dest, value, memory);
                    if dest == 6 || src == 6 {
                        7 // Memory access via (HL) takes 7 cycles
                    } else {
                        4 // Register-to-register takes 4 cycles
                    }
                }
            },

            // Add register or (HL) to A, setting all flags (H for carry from bit 3)
            0x80..=0x87 => self.add_a_r(self.get_register(opcode & 0x07, memory)), // ADD A, r

            // Add register or (HL) plus Carry to A, setting all flags
            0x88..=0x8F => {
                let r = self.get_register(opcode & 0x07, memory);
                self.adc_a_r(r);
                if (opcode & 0x07) == 6 { 7 } else { 4 } // (HL) takes 7, others 4 cycles
            }, // ADC A, r

            // Subtract register or (HL) from A, setting all flags (H for borrow)
            0x90..=0x97 => self.sub_a_r(self.get_register(opcode & 0x07, memory)), // SUB r

            // Subtract register or (HL) plus Carry from A, setting all flags
            0x98..=0x9F => {
                let r = self.get_register(opcode & 0x07, memory);
                self.sbc_a_r(r);
                if (opcode & 0x07) == 6 { 7 } else { 4 } // (HL) takes 7, others 4 cycles
            }, // SBC A, r

            // Bitwise AND of register or (HL) with A, setting S, Z, H, PV (N/C reset)
            0xA0..=0xA7 => {
                let r = self.get_register(opcode & 0x07, memory);
                self.and_a_r(r);
                if (opcode & 0x07) == 6 { 7 } else { 4 } // (HL) takes 7, others 4 cycles
            }, // AND r

            // Bitwise XOR of register or (HL) with A, setting S, Z, PV (H/N/C reset)
            0xA8..=0xAF => {
                let r = self.get_register(opcode & 0x07, memory);
                self.xor_a_r(r);
                if (opcode & 0x07) == 6 { 7 } else { 4 } // (HL) takes 7, others 4 cycles
            }, // XOR r

            // Bitwise OR of register or (HL) with A, setting S, Z, PV (H/N/C reset)
            0xB0..=0xB7 => {
                let r = self.get_register(opcode & 0x07, memory);
                self.or_a_r(r);
                if (opcode & 0x07) == 6 { 7 } else { 4 } // (HL) takes 7, others 4 cycles
            }, // OR r

            // Compare register or (HL) with A (A - r), setting all flags, A unchanged
            0xB8..=0xBF => {
                let r = self.get_register(opcode & 0x07, memory);
                let a = self.registers.a;
                let result = a.wrapping_sub(r);
                let half_carry = (a & 0x0F) < (r & 0x0F);
                let overflow = ((a ^ r) & 0x80 != 0) && ((a ^ result) & 0x80 != 0);
                let carry = a < r;
                self.registers.set_flag(FLAG_S, result & 0x80 != 0);
                self.registers.set_flag(FLAG_Z, result == 0);
                self.registers.set_flag(FLAG_H, half_carry);
                self.registers.set_flag(FLAG_PV, overflow);
                self.registers.set_flag(FLAG_N, true);
                self.registers.set_flag(FLAG_C, carry);
                if (opcode & 0x07) == 6 { 7 } else { 4 } // (HL) takes 7, others 4 cycles
            }, // CP r

            // Pop BC from stack: C from (SP), B from (SP+1), then SP += 2
            0xC1 => {
                self.registers.c = memory.read(self.registers.sp);
                self.registers.b = memory.read(self.registers.sp + 1);
                self.registers.sp = self.registers.sp.wrapping_add(2);
                10
            }, // POP BC

            // Jump if Zero flag is reset (NZ): PC = nn if Z = 0 (always 10 cycles)
            0xC2 => {
                let nn = self.fetch_word(memory);
                if !self.registers.get_flag(FLAG_Z) {
                    self.registers.pc = nn;
                }
                10
            }, // JP NZ, nn

            // Jump absolute: Set PC to 16-bit address nn from memory (PC+1, PC+2)
            0xC3 => { self.registers.pc = self.fetch_word(memory); 10 }, // JP nn

            // Call subroutine if Zero flag is reset (NZ): Push PC, PC = nn if Z = 0
            0xC4 => {
                let nn = self.fetch_word(memory);
                if !self.registers.get_flag(FLAG_Z) {
                    self.push_pc(memory);
                    self.registers.pc = nn;
                    17
                } else {
                    10
                }
            }, // CALL NZ, nn

            // Push BC to stack: SP -= 2, (SP+1) = B, (SP) = C
            0xC5 => {
                self.registers.sp = self.registers.sp.wrapping_sub(2);
                memory.write(self.registers.sp + 1, self.registers.b);
                memory.write(self.registers.sp, self.registers.c);
                11 // Note: Corrected to 11 cycles per Z80 manual
            }, // PUSH BC

            // Add immediate value n to A, setting all flags
            0xC6 => {
                let n = self.fetch_byte(memory);
                self.add_a_r(n);
                7 // Clock cycles for ADD A, n
            }, // ADD A, n

            // Restart at 0x00: Push PC, set PC to 0x0000
            0xC7 => {
                self.push_pc(memory);
                self.registers.pc = 0x0000;
                11
            }, // RST 00H

            // Return if Zero flag is reset (NZ): Pop PC if Z = 0
            0xC0 => {
                if !self.registers.get_flag(FLAG_Z) {
                    self.pop_pc(memory);
                    11
                } else {
                    5
                }
            }, // RET NZ

            // Pop HL from stack: L from (SP), H from (SP+1), then SP += 2
            0xE1 => {
                self.registers.l = memory.read(self.registers.sp);
                self.registers.h = memory.read(self.registers.sp + 1);
                self.registers.sp = self.registers.sp.wrapping_add(2);
                10
            }, // POP HL

            // Jump if Zero flag is set (Z): PC = nn if Z = 1 (always 10 cycles)
            0xCA => {
                let nn = self.fetch_word(memory);
                if self.registers.get_flag(FLAG_Z) {
                    self.registers.pc = nn;
                }
                10
            }, // JP Z, nn

            // CB prefix: Fetch next byte and execute bit operation
            0xCB => { let cb_opcode = self.fetch_byte(memory); self.execute_cb(cb_opcode, memory) },

            // Call subroutine if Zero flag is set (Z): Push PC, PC = nn if Z = 1
            0xCC => {
                let nn = self.fetch_word(memory);
                if self.registers.get_flag(FLAG_Z) {
                    self.push_pc(memory);
                    self.registers.pc = nn;
                    17
                } else {
                    10
                }
            }, // CALL Z, nn

            // Call subroutine: Push PC, set PC to nn
            0xCD => {
                let nn = self.fetch_word(memory);
                self.push_pc(memory);
                self.registers.pc = nn;
                17
            }, // CALL nn

            // Add immediate value n plus Carry to A, setting all flags
            0xCE => {
                let n = self.fetch_byte(memory);
                self.adc_a_r(n);
                7
            }, // ADC A, n

            // Restart at 0x08: Push PC, set PC to 0x0008
            0xCF => {
                self.push_pc(memory);
                self.registers.pc = 0x0008;
                11
            }, // RST 08H

            // Return if Zero flag is set (Z): Pop PC if Z = 1
            0xC8 => {
                if self.registers.get_flag(FLAG_Z) {
                    self.pop_pc(memory);
                    11
                } else {
                    5
                }
            }, // RET Z

            // Return: Pop PC from stack
            0xC9 => { self.pop_pc(memory); 10 }, // RET

            // Jump if Carry flag is reset (NC): PC = nn if C = 0
            0xD2 => {
                let nn = self.fetch_word(memory);
                if !self.registers.get_flag(FLAG_C) {
                    self.registers.pc = nn;
                }
                10
            }, // JP NC, nn

            // Output A to port n: Port address from (PC+1)
            0xD3 => {
                let n = self.fetch_byte(memory); // Get the port number from memory
                io.write(n as u16, self.registers.a); // Write A's value to the port
                11 // Return the number of clock cycles
            }, // OUT (n), A

            // Call subroutine if Carry flag is reset (NC): Push PC, PC = nn if C = 0
            0xD4 => {
                let nn = self.fetch_word(memory);
                if !self.registers.get_flag(FLAG_C) {
                    self.push_pc(memory);
                    self.registers.pc = nn;
                    17
                } else {
                    10
                }
            }, // CALL NC, nn

            // Push DE to stack: SP -= 2, (SP+1) = D, (SP) = E
            0xD5 => {
                self.registers.sp = self.registers.sp.wrapping_sub(2);
                memory.write(self.registers.sp + 1, self.registers.d);
                memory.write(self.registers.sp, self.registers.e);
                11
            }, // PUSH DE

            // Subtract immediate value n from A, setting all flags
            0xD6 => {
                let n = self.fetch_byte(memory);
                self.sub_a_r(n);
                7 // Clock cycles for SUB n
            }, // SUB n

            // Restart at 0x10: Push PC, set PC to 0x0010
            0xD7 => {
                self.push_pc(memory);
                self.registers.pc = 0x0010;
                11
            }, // RST 10H

            // Return if Carry flag is reset (NC): Pop PC if C = 0
            0xD0 => {
                if !self.registers.get_flag(FLAG_C) {
                    self.pop_pc(memory);
                    11
                } else {
                    5
                }
            }, // RET NC

            // Pop DE from stack: E from (SP), D from (SP+1), then SP += 2
            0xD1 => {
                self.registers.e = memory.read(self.registers.sp);
                self.registers.d = memory.read(self.registers.sp + 1);
                self.registers.sp = self.registers.sp.wrapping_add(2);
                10
            }, // POP DE

            // Jump if Carry flag is set (C): PC = nn if C = 1
            0xDA => {
                let nn = self.fetch_word(memory);
                if self.registers.get_flag(FLAG_C) {
                    self.registers.pc = nn;
                }
                10
            }, // JP C, nn

            // Input from port n to A: Port address from (PC+1)
            0xDB => {
                let n = self.fetch_byte(memory);
                self.registers.a = io.read(n as u16);
                11
            }, // IN A, (n)

            // Call subroutine if Carry flag is set (C): Push PC, PC = nn if C = 1
            0xDC => {
                let nn = self.fetch_word(memory);
                if self.registers.get_flag(FLAG_C) {
                    self.push_pc(memory);
                    self.registers.pc = nn;
                    17
                } else {
                    10
                }
            }, // CALL C, nn

            // DD prefix: Fetch next byte and execute IX-related instruction
            0xDD => { let dd_opcode = self.fetch_byte(memory); self.execute_dd(dd_opcode, memory, io) },

            // Subtract immediate value n plus Carry from A, setting all flags
            0xDE => {
                let n = self.fetch_byte(memory);
                self.sbc_a_r(n);
                7
            }, // SBC A, n

            // Restart at 0x18: Push PC, set PC to 0x0018
            0xDF => {
                self.push_pc(memory);
                self.registers.pc = 0x0018;
                11
            }, // RST 18H

            // Return if Carry flag is set (C): Pop PC if C = 1
            0xD8 => {
                if self.registers.get_flag(FLAG_C) {
                    self.pop_pc(memory);
                    11
                } else {
                    5
                }
            }, // RET C

            // Exchange DE with HL: Swap register pairs
            0xEB => {
                let temp_d = self.registers.d;
                let temp_e = self.registers.e;
                self.registers.d = self.registers.h;
                self.registers.e = self.registers.l;
                self.registers.h = temp_d;
                self.registers.l = temp_e;
                4
            }, // EX DE, HL

            // Jump if Parity Odd (PO): PC = nn if PV = 0
            0xE2 => {
                let nn = self.fetch_word(memory);
                if !self.registers.get_flag(FLAG_PV) {
                    self.registers.pc = nn;
                }
                10
            }, // JP PO, nn

            // Jump indirect via HL: PC = HL
            0xE9 => {
                self.registers.pc = self.registers.get_hl();
                4
            }, // JP (HL)

            // Call subroutine if Parity Odd (PO): Push PC, PC = nn if PV = 0
            0xE4 => {
                let nn = self.fetch_word(memory);
                if !self.registers.get_flag(FLAG_PV) {
                    self.push_pc(memory);
                    self.registers.pc = nn;
                    17
                } else {
                    10
                }
            }, // CALL PO, nn

            // Push HL to stack: SP -= 2, (SP+1) = H, (SP) = L
            0xE5 => {
                self.registers.sp = self.registers.sp.wrapping_sub(2);
                memory.write(self.registers.sp + 1, self.registers.h);
                memory.write(self.registers.sp, self.registers.l);
                11
            }, // PUSH HL

            // Bitwise AND of immediate n with A, setting S, Z, H, PV (N/C reset)
            0xE6 => {
                let n = self.fetch_byte(memory);
                self.and_a_r(n);
                7
            }, // AND n

            // Restart at 0x20: Push PC, set PC to 0x0020
            0xE7 => {
                self.push_pc(memory);
                self.registers.pc = 0x0020;
                11
            }, // RST 20H

            // Return if Parity Odd (PO): Pop PC if PV = 0
            0xE0 => {
                if !self.registers.get_flag(FLAG_PV) {
                    self.pop_pc(memory);
                    11
                } else {
                    5
                }
            }, // RET PO

            // Exchange (SP) with HL: Swap HL with top of stack
            0xE3 => {
                let low = memory.read(self.registers.sp);
                let high = memory.read(self.registers.sp + 1);
                memory.write(self.registers.sp, self.registers.l);
                memory.write(self.registers.sp + 1, self.registers.h);
                self.registers.l = low;
                self.registers.h = high;
                19
            }, // EX (SP), HL

            // Jump if Parity Even (PE): PC = nn if PV = 1
            0xEA => {
                let nn = self.fetch_word(memory);
                if self.registers.get_flag(FLAG_PV) {
                    self.registers.pc = nn;
                }
                10
            }, // JP PE, nn

            // Bitwise XOR of immediate n with A, setting S, Z, PV (H/N/C reset)
            0xEE => {
                let n = self.fetch_byte(memory);
                self.xor_a_r(n);
                7
            }, // XOR n

            // Restart at 0x28: Push PC, set PC to 0x0028
            0xEF => {
                self.push_pc(memory);
                self.registers.pc = 0x0028;
                11
            }, // RST 28H

            // Return if Parity Even (PE): Pop PC if PV = 1
            0xE8 => {
                if self.registers.get_flag(FLAG_PV) {
                    self.pop_pc(memory);
                    11
                } else {
                    5
                }
            }, // RET PE

            // Call subroutine if Parity Even (PE): Push PC, PC = nn if PV = 1
            0xEC => {
                let nn = self.fetch_word(memory);
                if self.registers.get_flag(FLAG_PV) {
                    self.push_pc(memory);
                    self.registers.pc = nn;
                    17
                } else {
                    10
                }
            }, // CALL PE, nn

            // Pop AF from stack: F from (SP), A from (SP+1), then SP += 2
            0xF1 => {
                self.registers.f = memory.read(self.registers.sp);
                self.registers.a = memory.read(self.registers.sp + 1);
                self.registers.sp = self.registers.sp.wrapping_add(2);
                10
            }, // POP AF

            // Jump if Positive (P): PC = nn if S = 0
            0xF2 => {
                let nn = self.fetch_word(memory);
                if !self.registers.get_flag(FLAG_S) {
                    self.registers.pc = nn;
                }
                10
            }, // JP P, nn

            // Disable Interrupts: Clear both interrupt flip-flops
            0xF3 => {
                self.iff1 = false;
                self.iff2 = false;
                4
            }, // DI

            // Call subroutine if Positive (P): Push PC, PC = nn if S = 0
            0xF4 => {
                let nn = self.fetch_word(memory);
                if !self.registers.get_flag(FLAG_S) {
                    self.push_pc(memory);
                    self.registers.pc = nn;
                    17
                } else {
                    10
                }
            }, // CALL P, nn

            // Push AF to stack: SP -= 2, (SP+1) = A, (SP) = F
            0xF5 => {
                self.registers.sp = self.registers.sp.wrapping_sub(2);
                memory.write(self.registers.sp + 1, self.registers.a);
                memory.write(self.registers.sp, self.registers.f);
                11
            }, // PUSH AF

            // Bitwise OR of immediate n with A, setting S, Z, PV (H/N/C reset)
            0xF6 => {
                let n = self.fetch_byte(memory);
                self.or_a_r(n);
                7
            }, // OR n

            // Restart at 0x30: Push PC, set PC to 0x0030
            0xF7 => {
                self.push_pc(memory);
                self.registers.pc = 0x0030;
                11
            }, // RST 30H

            // Return if Positive (P): Pop PC if S = 0
            0xF0 => {
                if !self.registers.get_flag(FLAG_S) {
                    self.pop_pc(memory);
                    11
                } else {
                    5
                }
            }, // RET P

            // Load SP with HL: SP = HL
            0xF9 => { // Note: Overlaps with ADD HL, SP; corrected below
                self.registers.sp = self.registers.get_hl();
                6
            }, // LD SP, HL
            
            // Jump if Minus (M): PC = nn if S = 1
            0xFA => {
                let nn = self.fetch_word(memory);
                if self.registers.get_flag(FLAG_S) {
                    self.registers.pc = nn;
                }
                10
            }, // JP M, nn

            // Call subroutine if Minus (M): Push PC, PC = nn if S = 1
            0xFC => {
                let nn = self.fetch_word(memory);
                if self.registers.get_flag(FLAG_S) {
                    self.push_pc(memory);
                    self.registers.pc = nn;
                    17
                } else {
                    10
                }
            }, // CALL M, nn

            // Enable Interrupts: Set both interrupt flip-flops after next instruction
            0xFB => { self.iff1 = true; self.iff2 = true; 4 }, // EI

            // Compare immediate n with A (A - n), setting all flags, A unchanged
            0xFE => {
                let n = self.fetch_byte(memory);
                let a = self.registers.a;
                let result = a.wrapping_sub(n);
                let half_carry = (a & 0x0F) < (n & 0x0F);
                let overflow = ((a ^ n) & 0x80 != 0) && ((a ^ result) & 0x80 != 0);
                let carry = a < n;
                self.registers.set_flag(FLAG_S, result & 0x80 != 0);
                self.registers.set_flag(FLAG_Z, result == 0);
                self.registers.set_flag(FLAG_H, half_carry);
                self.registers.set_flag(FLAG_PV, overflow);
                self.registers.set_flag(FLAG_N, true);
                self.registers.set_flag(FLAG_C, carry);
                7
            }, // CP n

            // Restart at 0x38: Push PC, set PC to 0x0038
            0xFF => {
                self.push_pc(memory);
                self.registers.pc = 0x0038;
                11
            }, // RST 38H

            // Return if Minus (M): Pop PC if S = 1
            0xF8 => {
                if self.registers.get_flag(FLAG_S) {
                    self.pop_pc(memory);
                    11
                } else {
                    5
                }
            }, // RET M

            // FD prefix: Fetch next byte and execute IY-related instruction
            0xFD => { let fd_opcode = self.fetch_byte(memory); self.execute_fd(fd_opcode, memory, io) },

            // ED prefix: Fetch next byte and execute extended instruction
            0xED => { let ed_opcode = self.fetch_byte(memory); self.execute_ed(ed_opcode, memory, io) },

            // Unimplemented opcodes trigger a panic with the opcode value
            _ => unimplemented!("Opcode {:#04x} not implemented", opcode),
        }
    }

    /// Executes CB-prefixed instructions (bit operations).
    fn execute_cb(&mut self, opcode: u8, memory: &mut dyn Z80Memory) -> u8 {
        let r = opcode & 0x07;
        let b = (opcode >> 3) & 0x07;
        match opcode >> 6 {
            0 => match (opcode >> 3) & 0x07 {
                0 => self.rlc_r(r, memory), // RLC r
                _ => unimplemented!("CB opcode {:#04x} not implemented", opcode),
            },
            1 => self.bit_b_r(b, r, memory), // BIT b, r
            2 => self.res_b_r(b, r, memory), // RES b, r
            3 => self.set_b_r(b, r, memory), // SET b, r
            _ => unreachable!("Invalid CB opcode prefix"),
        }
    }

    /// Executes DD-prefixed instructions (IX operations).
    fn execute_dd(&mut self, opcode: u8, memory: &mut dyn Z80Memory, _io: &mut dyn IoDevice) -> u8 {
        match opcode {
            0x21 => { self.registers.ix = self.fetch_word(memory); 14 }, // LD IX, nn
            0x36 => { // LD (IX+d), n
                let d = self.fetch_byte(memory) as i8;
                let n = self.fetch_byte(memory);
                memory.write(self.registers.ix.wrapping_add(d as u16), n);
                19
            },
            _ => unimplemented!("DD opcode {:#04x} not implemented", opcode),
        }
    }

    /// Executes ED-prefixed instructions (extended operations).
    fn execute_ed(&mut self, opcode: u8, memory: &mut dyn Z80Memory, _io: &mut dyn IoDevice) -> u8 {
        match opcode {
            0x56 => { self.im = 1; 8 }, // IM 1
            0xB0 => self.ldir(memory),  // LDIR
            _ => unimplemented!("ED opcode {:#04x} not implemented", opcode),
        }
    }

    /// Executes FD-prefixed instructions (IY operations).
    fn execute_fd(&mut self, opcode: u8, memory: &mut dyn Z80Memory, _io: &mut dyn IoDevice) -> u8 {
        match opcode {
            0x21 => { self.registers.iy = self.fetch_word(memory); 14 }, // LD IY, nn
            0x7E => { // LD A, (IY+d)
                let d = self.fetch_byte(memory) as i8;
                self.registers.a = memory.read(self.registers.iy.wrapping_add(d as u16));
                19
            },
            _ => unimplemented!("FD opcode {:#04x} not implemented", opcode),
        }
    }

    /// ADD A, r: Adds register r to A, updating flags.
    fn add_a_r(&mut self, r: u8) -> u8 {
        let a = self.registers.a;
        let result = a.wrapping_add(r);
        let half_carry = (a & 0x0F) + (r & 0x0F) > 0x0F;
        let overflow = ((a ^ r) & 0x80) == 0 && ((a ^ result) & 0x80) != 0;
        let carry = (a as u16) + (r as u16) > 0xFF;
        self.registers.a = result;
        self.registers.set_flag(FLAG_S, result & 0x80 != 0);
        self.registers.set_flag(FLAG_Z, result == 0);
        self.registers.set_flag(FLAG_H, half_carry);
        self.registers.set_flag(FLAG_PV, overflow);
        self.registers.set_flag(FLAG_N, false);
        self.registers.set_flag(FLAG_C, carry);
        if r == 6 { 7 } else { 4 } // (HL) takes 7 cycles, others 4
    }

    /// SUB r: Subtracts register r from A, updating flags.
    fn sub_a_r(&mut self, r: u8) -> u8 {
        let a = self.registers.a;
        let result = a.wrapping_sub(r);
        let half_carry = (a & 0x0F) < (r & 0x0F);
        let overflow = ((a ^ r) & 0x80) != 0 && ((a ^ result) & 0x80) != 0;
        let carry = a < r;
        self.registers.a = result;
        self.registers.set_flag(FLAG_S, result & 0x80 != 0);
        self.registers.set_flag(FLAG_Z, result == 0);
        self.registers.set_flag(FLAG_H, half_carry);
        self.registers.set_flag(FLAG_PV, overflow);
        self.registers.set_flag(FLAG_N, true);
        self.registers.set_flag(FLAG_C, carry);
        if r == 6 { 7 } else { 4 } // (HL) takes 7 cycles, others 4
    }

    /// BIT b, r: Tests bit b in register r, setting flags.
    fn bit_b_r(&mut self, b: u8, r: u8, memory: &dyn Z80Memory) -> u8 {
        let value = self.get_register(r, memory);
        let bit = 1 << b;
        let zero = value & bit == 0;
        self.registers.set_flag(FLAG_Z, zero);
        self.registers.set_flag(FLAG_N, false);
        self.registers.set_flag(FLAG_H, true);
        if r == 6 { 12 } else { 8 } // (HL) takes 12 cycles, others 8
    }

    /// RES b, r: Resets bit b in register r.
    fn res_b_r(&mut self, b: u8, r: u8, memory: &mut dyn Z80Memory) -> u8 {
        let value = self.get_register(r, memory);
        let result = value & !(1 << b);
        self.set_register(r, result, memory);
        if r == 6 { 15 } else { 8 } // (HL) takes 15 cycles, others 8
    }

    /// SET b, r: Sets bit b in register r.
    fn set_b_r(&mut self, b: u8, r: u8, memory: &mut dyn Z80Memory) -> u8 {
        let value = self.get_register(r, memory);
        let result = value | (1 << b);
        self.set_register(r, result, memory);
        if r == 6 { 15 } else { 8 } // (HL) takes 15 cycles, others 8
    }

    /// RLC r: Rotates register r left, setting flags.
    fn rlc_r(&mut self, r: u8, memory: &mut dyn Z80Memory) -> u8 {
        let value = self.get_register(r, memory);
        let carry = value & 0x80 != 0;
        let result = (value << 1) | if carry { 1 } else { 0 };
        self.set_register(r, result, memory);
        self.registers.set_flag(FLAG_S, result & 0x80 != 0);
        self.registers.set_flag(FLAG_Z, result == 0);
        self.registers.set_flag(FLAG_H, false);
        self.registers.set_flag(FLAG_PV, Self::parity(result));
        self.registers.set_flag(FLAG_N, false);
        self.registers.set_flag(FLAG_C, carry);
        if r == 6 { 15 } else { 8 } // (HL) takes 15 cycles, others 8
    }

    /// LDIR: Block transfer from (HL) to (DE), repeats until BC = 0.
    fn ldir(&mut self, memory: &mut dyn Z80Memory) -> u8 {
        let hl = self.registers.get_hl();
        let de = self.registers.get_de();
        let bc = self.registers.get_bc();
        let value = memory.read(hl);
        memory.write(de, value);
        let new_bc = bc.wrapping_sub(1);
        self.registers.set_hl(hl.wrapping_add(1));
        self.registers.set_de(de.wrapping_add(1));
        self.registers.set_bc(new_bc);
        self.registers.set_flag(FLAG_H, false);
        self.registers.set_flag(FLAG_N, false);
        self.registers.set_flag(FLAG_PV, new_bc != 0);
        if new_bc != 0 {
            self.registers.pc = self.registers.pc.wrapping_sub(2);
            21 // Repeat takes 21 cycles
        } else {
            16 // Non-repeat takes 16 cycles
        }
    }

    /// Computes parity (true if even number of 1 bits).
    fn parity(value: u8) -> bool {
        value.count_ones() % 2 == 0
    }

    fn inc_8bit(&mut self, value: u8) -> u8 {
        let result = value.wrapping_add(1);
        let half_carry = (value & 0x0F) == 0x0F;
        let overflow = value == 0x7F;
        self.registers.set_flag(FLAG_S, result & 0x80 != 0);
        self.registers.set_flag(FLAG_Z, result == 0);
        self.registers.set_flag(FLAG_H, half_carry);
        self.registers.set_flag(FLAG_PV, overflow);
        self.registers.set_flag(FLAG_N, false);
        result
    }

    fn dec_8bit(&mut self, value: u8) -> u8 {
        let result = value.wrapping_sub(1);
        let half_carry = (value & 0x0F) == 0;
        let overflow = value == 0x80;
        self.registers.set_flag(FLAG_S, result & 0x80 != 0);
        self.registers.set_flag(FLAG_Z, result == 0);
        self.registers.set_flag(FLAG_H, half_carry);
        self.registers.set_flag(FLAG_PV, overflow);
        self.registers.set_flag(FLAG_N, true);
        result
    }

    fn adc_a_r(&mut self, r: u8) {
        let a = self.registers.a;
        let carry = if self.registers.get_flag(FLAG_C) { 1 } else { 0 };
        let result = a.wrapping_add(r).wrapping_add(carry);
        let half_carry = (a & 0x0F) + (r & 0x0F) + carry > 0x0F;
        let overflow = ((a ^ r) & 0x80 != 0) && ((a ^ result) & 0x80 != 0);
        let carry_out = (a as u16) + (r as u16) + (carry as u16) > 0xFF;
        self.registers.a = result;
        self.registers.set_flag(FLAG_S, result & 0x80 != 0);
        self.registers.set_flag(FLAG_Z, result == 0);
        self.registers.set_flag(FLAG_H, half_carry);
        self.registers.set_flag(FLAG_PV, overflow);
        self.registers.set_flag(FLAG_N, false);
        self.registers.set_flag(FLAG_C, carry_out);
    }

    fn sbc_a_r(&mut self, r: u8) {
        let a = self.registers.a;
        let carry = if self.registers.get_flag(FLAG_C) { 1 } else { 0 };
        let result = a.wrapping_sub(r).wrapping_sub(carry);
        let half_carry = (a & 0x0F) < (r & 0x0F) + carry;
        let overflow = ((a ^ r) & 0x80 != 0) && ((a ^ result) & 0x80 != 0);
        let carry_out = (a as u16) < (r as u16) + (carry as u16);
        self.registers.a = result;
        self.registers.set_flag(FLAG_S, result & 0x80 != 0);
        self.registers.set_flag(FLAG_Z, result == 0);
        self.registers.set_flag(FLAG_H, half_carry);
        self.registers.set_flag(FLAG_PV, overflow);
        self.registers.set_flag(FLAG_N, true);
        self.registers.set_flag(FLAG_C, carry_out);
    }

    fn and_a_r(&mut self, r: u8) {
        self.registers.a &= r;
        let result = self.registers.a;
        self.registers.set_flag(FLAG_S, result & 0x80 != 0);
        self.registers.set_flag(FLAG_Z, result == 0);
        self.registers.set_flag(FLAG_H, true);
        self.registers.set_flag(FLAG_PV, Self::parity(result));
        self.registers.set_flag(FLAG_N, false);
        self.registers.set_flag(FLAG_C, false);
    }

    fn xor_a_r(&mut self, r: u8) {
        self.registers.a ^= r;
        let result = self.registers.a;
        self.registers.set_flag(FLAG_S, result & 0x80 != 0);
        self.registers.set_flag(FLAG_Z, result == 0);
        self.registers.set_flag(FLAG_H, false);
        self.registers.set_flag(FLAG_PV, Self::parity(result));
        self.registers.set_flag(FLAG_N, false);
        self.registers.set_flag(FLAG_C, false);
    }

    fn or_a_r(&mut self, r: u8) {
        self.registers.a |= r;
        let result = self.registers.a;
        self.registers.set_flag(FLAG_S, result & 0x80 != 0);
        self.registers.set_flag(FLAG_Z, result == 0);
        self.registers.set_flag(FLAG_H, false);
        self.registers.set_flag(FLAG_PV, Self::parity(result));
        self.registers.set_flag(FLAG_N, false);
        self.registers.set_flag(FLAG_C, false);
    }

    /// Triggers a Non-Maskable Interrupt (NMI).
    pub fn trigger_nmi(&mut self, memory: &mut dyn Z80Memory) {
        self.halted = false;
        self.iff2 = self.iff1;
        self.iff1 = false;
        self.push_pc(memory);
        self.registers.pc = 0x0066; // NMI vector
        self.cycles += 11;
    }

    /// Triggers a maskable interrupt with the given bus value.
    pub fn trigger_int(&mut self, memory: &mut dyn Z80Memory, io: &mut dyn IoDevice, bus_value: u8) -> u8 {
        if self.iff1 {
            self.halted = false;
            self.iff1 = false;
            self.iff2 = false;
            match self.im {
                0 => {
                    self.execute(bus_value, memory, io);
                    13 // Approximate for typical RST instruction
                },
                1 => {
                    self.push_pc(memory);
                    self.registers.pc = 0x0038; // IM 1 vector
                    self.cycles += 13;
                    13
                },
                2 => {
                    let addr = ((self.registers.i as u16) << 8) | bus_value as u16;
                    let low = memory.read(addr);
                    let high = memory.read(addr + 1);
                    let jump_addr = ((high as u16) << 8) | low as u16;
                    self.push_pc(memory);
                    self.registers.pc = jump_addr;
                    self.cycles += 19;
                    19
                },
                _ => unreachable!("Invalid interrupt mode"),
            }
        } else {
            0 // No cycles if interrupt not taken
        }
    }

    // Getter methods for testing
    pub fn get_a(&self) -> u8 { self.registers.a }
    pub fn get_b(&self) -> u8 { self.registers.b }
    pub fn get_bc(&self) -> u16 { self.registers.get_bc() }
    pub fn get_de(&self) -> u16 { self.registers.get_de() }
    pub fn get_hl(&self) -> u16 { self.registers.get_hl() }
    pub fn get_sp(&self) -> u16 { self.registers.sp }
    pub fn get_pc(&self) -> u16 { self.registers.pc }
    pub fn get_ix(&self) -> u16 { self.registers.ix }
    pub fn get_iy(&self) -> u16 { self.registers.iy }
    pub fn get_flag(&self, flag: u8) -> bool { self.registers.get_flag(flag) }
    pub fn is_halted(&self) -> bool { self.halted }

    // Setter methods for testing
    pub fn set_a(&mut self, value: u8) { self.registers.a = value }
    pub fn set_sp(&mut self, value: u16) { self.registers.sp = value }
    pub fn set_flag(&mut self, flag: u8, value: bool) { self.registers.set_flag(flag, value) }
}

```